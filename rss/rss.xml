<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0">
  <channel>
    <title>TooBug</title>
    <link>http://www.toobug.net</link>
    <description>TooBug - 专注前端开发</description>
    <lastBuildDate>Tue, 28 May 2013 06:26:44 +0800</lastBuildDate>
    <generator>Solo 2.0</generator>
    <item>
      <title>[译]Shadow DOM第一课</title>
      <link>http://www.toobug.net/article/shadow_dom_101.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/shadow_dom_101.html</guid>
      <pubDate>Tue, 28 May 2013 06:26:44 +0800</pubDate>
      <category>Shadow DOM</category>
      <category>Web Components</category>
      <description>
        <![CDATA[
        <h2>译者按</h2>

<p>去年我曾经翻译过一篇<a href="http://www.toobug.net/article/what_is_shadow_dom.html">介绍Shadow DOM的文章</a>，当时觉得这是一门好遥远的技术，但仅仅在半年之后，Chrome就已经支持了Shadow DOM，到目前为止，Web Components的各个子标准也已经初见端倪，可以再深入把玩一番了。建议使用Chrome 25+访问本文章以便可以看到可以使用的实例，否则文章中的演示将只能看到静态的图片。</p>

<h2>简介</h2>

<blockquote>
  <p>注：本文讨论的API还没有被完全标准化，还处在不断讨论变更的阶段，所以请在项目中谨慎使用实验性的API。</p>
</blockquote>

<p><a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/explainer/index.html">Web Components</a>是一系列比较前卫的标准的集合，它可以：</p>

<ul>
<li>使得在页面中构建挂件（widget）成为可能</li>
<li>构建的挂件很可靠，可以被重复使用</li>
<li>如果挂件的下一个版本改变了内部实现细节，并不会影响页面</li>
</ul>

<p>这是否是说你得在使用HTML/JavaScript还是使用Web Components之间做出选择？事实上，不是的。HTML和JavaScript可以做出交互式的组件，而挂件正是这样的交互式组件。这也就是说使用HTML和JavaScript来开发挂件是件很有意义的事情。Web Components标准正是用来做这件事情的。</p>

<blockquote>
  <p>如果构建一个挂件必须要强制使用另外的技术，那么这是没有意义的。比如，使用<code>&lt;canvas&gt;</code>来构建一个挂件显然是件无趣的事情。它的确很可靠，因为当你改变画布中的内容时页面不会受影响，但它在可访问性、可索引性、内容创作、自适应分辨率等方面都很不友好。</p>
</blockquote>

<p>如果HTML和JavaScript来构建挂件面临一个基础性的问题，那就是挂件内的DOM树并没有被从页面其它部分封装起来。缺少封装意味着页面的CSS可能会意外地被应用到挂件内部，JavaScript可能会意外地修改挂件内部，还可能引起挂件内外的ID冲突等等。</p>

<blockquote>
  <p>缺少封装带来的另一方面的问题是，当你升级了你的库，改变了挂件的DOM结构，那么你的CSS和JavaScript有可能会意外地不能正常工作。</p>
</blockquote>

<p>Web Components由5个部分组成（译注：原文中是模板、Shadow DOM、自定义元素、Packaging四个部分，翻译时根据最新规范做了修改，感谢 <a href="http://weibo.com/jieorlin">@一丝</a> 提醒）：</p>

<ol>
<li><a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html">模板（Templates）</a></li>
<li><a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/explainer/index.html#decorator-section">装饰器（Decorators）</a></li>
<li><a href="http://www.w3.org/TR/shadow-dom/">Shadow DOM</a></li>
<li><a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html">自定义元素（Custom Elements）</a></li>
<li><a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/imports/index.html">Imports</a></li>
</ol>

<p>Shadow DOM着眼于DOM树的封装问题。Web Components的这5个部分在设计时是希望它们协同工作的，但你可以自由选择使用哪一部分。本教程将讨论如何使用Shadow DOM。</p>

<p>Shadow DOM目前只在Chrome 25+可用，API前面有一个<code>webkit</code>前缀。</p>

<h2>Hello, Shadow World</h2>

<p>在Shadow DOM的世界中，元素可以被关联到一种新的节点类型，这种新的节点类型叫作shadow root。一个被关联到shadow root的元素叫作shadow host。shadow host的内容不会被渲染，取而代之的是shadow root的内容。</p>

<p>比如，如果你有这样的代码：</p>

<pre><code>&lt;button&gt;Hello, world!&lt;/button&gt;
&lt;script&gt;
var host = document.querySelector('button');
var root = host.webkitCreateShadowRoot();
root.textContent = 'こんにちは、影の世界!';
&lt;/script&gt;
</code></pre>

<p>页面是像这样渲染的：</p>

<p><button>Hello, world!</button></p>

<script>
var host = document.querySelector('button');
var root = host.webkitCreateShadowRoot();
root.textContent = 'こんにちは、影の世界!';
</script>

<p>而不是这样：</p>

<p><button>Hello, world!</button></p>

<div class="helperimg" style="display:none;">
    <p>您的浏览器不支持Shadow DOM，这个例子的正确样子是这样的：</p>
    <p><img alt="不支持shadow dom的同学看这个图片" src="/images/shadow_dom_101_2.png" /></p>
</div>

<p>需要注意，如果使用页面上的JavaScript来取按钮的<code>textContent</code>，得到的并不是“こんにちは、影の世界!”，而是“Hello, world!”，因为shadow root下面的DOM子树被封装起来了。</p>

<p>这里可能违反了一个原则，就是不应该将内容放入Shadow DOM。内容必须被放到文档中，以便被屏幕阅读器、搜索引擎、浏览器插件等读取。Shadow DOM是用来处理在构建精致好用挂件过程中面临的无语义的标记的。内容部分应该留在页面上。</p>

<blockquote>
  <p>当然，对是否将内容放入Shadow DOM这件事，我们无法强制，毕竟这是web，你可以随意做你想做的事情。不要做得太过火就好。</p>
</blockquote>

<h2>将内容从表现中抽离</h2>

<p>现在我们来看一个使用Shadow DOM将内容从表现中抽离的例子。假设我们有这样一个名牌：</p>

<div id="nametag1" class="outer">
    <div class="boilerplate">
        Hi! My name is
    </div>
    <div class="name">
        Bob
    </div>
</div>

<blockquote>
  <p>译注：这个例子效果和原文略有差异，因为我的博客样式影响到了名牌的样式，刚好可以作为DOM不封装时写组件弊端的证明，就不修正了。</p>
</blockquote>

<p>下面是代码，这是你已经每天在写的代码，没有用到Shadow DOM：</p>

<pre><code>&lt;style&gt;
.outer {
    border: 2px solid brown;
    border-radius: 1em;
    background: red;
    font-size: 20pt;
    width: 12em;
    height: 7em;
    text-align: center;
}
.boilerplate {
    color: white;
    font-family: sans-serif;
    padding: 0.5em;
}
.name {
    color: black;
    background: white;
    font-family: "Marker Felt", cursive;
    font-size: 45pt;
    padding-top: 0.2em;
}
&lt;/style&gt;
&lt;div class="outer"&gt;
    &lt;div class="boilerplate"&gt;
        Hi! My name is
    &lt;/div&gt;
    &lt;div class="name"&gt;
        Bob
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>因为DOM树没有封装，名牌的整个结构都是暴露在文档中的。如果页面中碰巧有其它元素使用了相同的类名来写CSS或者JavaScript，那估计我们会很难过。</p>

<p>我们可以避免这种难过的日子。</p>

<h3>第1步，隐藏表现的细节</h3>

<p>从语义上讲，我们可能只关心：</p>

<ul>
<li>它是一个名牌</li>
<li>名字是“Bob”</li>
</ul>

<p>首先，我们写一个与我们期望的语义最接近的结构：</p>

<pre><code>&lt;div id="nameTag"&gt;Bob&lt;/div&gt;
</code></pre>

<p>接下来，我们将所有会用到的样式和<code>div</code>元素写到<code>&lt;template&gt;</code>元素中：</p>

<pre><code>&lt;div id="nameTag"&gt;Bob&lt;/div&gt;
&lt;template id="nameTagTemplate"&gt;
&lt;style&gt;
.outer {
    border: 2px solid brown;

    … same as above …

&lt;/style&gt;
&lt;div class="outer"&gt;
    &lt;div class="boilerplate"&gt;
        Hi! My name is
    &lt;/div&gt;
    &lt;div class="name"&gt;
        Bob
    &lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre>

<p>到目前为止，唯一被渲染的只有“Bob”，因为我们将用于表现的DOM结构移到了<code>&lt;template&gt;</code>元素中，它们没有被渲染，但我们可以从JavaScript中访问到这些DOM结构。现在，我们来处理shadow root：</p>

<pre><code>&lt;script&gt;
var shadow = document.querySelector('#nameTag').webkitCreateShadowRoot();
var template = document.querySelector('#nameTagTemplate');
shadow.appendChild(template.content);
template.remove();
&lt;/script&gt;
</code></pre>

<blockquote>
  <p>模板（Templates）和Shadow DOM一样，也是一个还未完全确定的标准。目前<code>&lt;template&gt;</code>元素在Chrome Canary中可用。你也可以使用你熟悉的方法如<code>innerHTML</code>，<code>appendChild</code>，<code>getElementById</code>等等。因为这篇文章是讲Shadow DOM的，所以我们不会深入去讲<code>template</code>元素是如何工作的。如果你希望了解更多，可以看<a href="http://www.html5rocks.com/tutorials/webcomponents/template/">HTML's New Template Tag</a>。</p>
</blockquote>

<p>现在我们有了一个shadow root，名牌又重新被渲染了。如果你在名牌标签上点右键然后审查元素，你会看到我们所期望的语义化的结构：</p>

<pre><code>&lt;div id="nameTag"&gt;Bob&lt;/div&gt;
</code></pre>

<p>从这个示例，我们可以看到，使用Shadow DOM可以将名牌的具体表现细节从文档中隐藏起来，它们被封装在了Shadow DOM中。</p>

<h3>　第2步，从表现中抽离内容</h3>

<p>现在我们的名牌可以将实现细节从页面中隐藏了，但其实并没有将内容和表现分享开，因为尽管内容（“Bob”）已经在页面上了，但被渲染的内容却是来自shadow root中的副本。如果我们需要修改名牌中的名字，还需要改这两个地方，甚至可能因为一些原因导致这两处的名字并不一致。</p>

<p>HTML元素是可以组合的——比如你可以将一个按钮放进一个表格中。在这里我们所需要的正是组合——名牌由一个红色的背景，文本“Hi!”以及名字组合而成。</p>

<p>你——即挂件的作者——可以通过一个叫<code>&lt;content&gt;</code>的新元素来定义你的挂件将如何被组合。这将在挂件的表现中创建一个插入点（insertion point），插入点会将shadow host中的内容放到插入点所在的位置。</p>

<p>如果我们将Shadow DOM中的结构改成这样：</p>

<pre><code>&lt;template id="nameTagTemplate"&gt;
&lt;style&gt;
    …
&lt;/style&gt;
&lt;div class="outer"&gt;
    &lt;div class="boilerplate"&gt;
        Hi! My name is
    &lt;/div&gt;
    &lt;div class="name"&gt;
        &lt;content&gt;&lt;/content&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre>

<p>如果这个名牌被渲染，那么shadow host的内容将被投影（project）到<code>&lt;content&gt;</code>元素出现的地方。</p>

<p>现在文档的结构显得更简单了，因为名字只出现在一个地方，即文档中。如果需要修改页面中的名字，只需要这样写就可以了：</p>

<pre><code>document.querySelector('#nameTag').textContent = 'Shellie';
</code></pre>

<p>浏览器会自动更新渲染结果，因为名字被投影到了<code>&lt;content&gt;</code>元素所在的地方。</p>

<p>这是一个实例：</p>

<div id="nameTag2">Bob</div>
<template id="nameTag2Template">
<style>
.outer {
  border: 2px solid brown;
  border-radius: 1em;
  background: red;
  font-size: 20pt;
  width: 12em;
  height: 7em;
  text-align: center;
}
.boilerplate {
  color: white;
  font-family: sans-serif;
  padding: 0.5em;
}
.name {
  color: black;
  background: white;
  font-family: "Marker Felt", cursive;
  font-size: 45pt;
  padding-top: 0.2em;
  height: 55pt;
  overflow: hidden;
}
</style>
<div class="outer">
    <div class="boilerplate">
        Hi! My name is
    </div>
    <div class="name">
        <content></content>
    </div>
</div>

<p></template></p>

<p>
<label for="name2newName">New name:</label>
<input name="name2newName" value="Shellie">
<button onclick="document.querySelector('#nameTag2').innerText=document.querySelector('input[name=name2newName]').value;">Update</button>
</p>

<script>
var shadow = document.querySelector('#nameTag2').webkitCreateShadowRoot();
var template = document.querySelector('#nameTag2Template');
shadow.appendChild(template.content);
template.remove();
</script>

<div class="helperimg" style="display:none;">
    <p>您的浏览器不支持Shadow DOM，这个例子的正确样子是这样的：</p>
    <p><img alt="不支持shadow dom的同学看这个图片" src="/images/shadow_dom_101_3.png" /></p>
</div>

<p>现在我们完成了内容与表现的分离。内容在文档中，而表现在Shadow DOM中。如果浏览器需要渲染的话，会自动将它们进行同步。</p>

<h3>第3步，好处</h3>

<p>通过分离内容和表现，我们可以简化对内容的操作，比如在上例中，你只需要操作一个<code>&lt;div&gt;</code>而不是一堆DOM。</p>

<p>现在如果我们要修改表现，根本不需要改任何代码。</p>

<p>比如，如果我们要对名牌进行本地化。这个名牌在文档中的语义化结构并没有改变：</p>

<pre><code>&lt;div id="nameTag"&gt;Bob&lt;/div&gt;
</code></pre>

<p>初始化shadow root的代码仍然和上面的相同，变化的只是放入shadow root中的内容：</p>

<pre><code>&lt;template id="nameTagTemplate"&gt;
&lt;style&gt;
.outer {
    border: 2px solid pink;
    border-radius: 1em;
    background: url(sakura.jpg);
    font-size: 20pt;
    width: 12em;
    height: 7em;
    text-align: center;
    font-family: sans-serif;
    font-weight: bold;
}
.name {
    font-size: 45pt;
    font-weight: normal;
    margin-top: 0.8em;
    padding-top: 0.2em;
}
&lt;/style&gt;
&lt;div class="outer"&gt;
    &lt;div class="name"&gt;
        &lt;content&gt;&lt;/content&gt;
    &lt;/div&gt;
    と申します。
&lt;/div&gt;
&lt;/template&gt;
</code></pre>

<p>现在我们看到了一个日本名牌（译注：原例如此，钓鱼岛是中国的！）：</p>

<div id="nameTag3">Bob</div>
<template id="nameTag3Template">
<style>
.outer {
    border: 2px solid pink;
    border-radius: 1em;
    background: url(/images/shadow_dom_101_1.jpg);
    font-size: 20pt;
    width: 12em;
    height: 7em;
    text-align: center;
    font-family: sans-serif;
    font-weight: bold;
}
.name {
    font-size: 45pt;
    font-weight: normal;
    margin-top: 0.8em;
    padding-top: 0.2em;
}
</style>
<div class="outer">
    <div class="name">
        <content></content>
    </div>
    と申します。
</div>

<p></template></p>

<p>
<label for="name3newName">New name:</label>
<input name="name3newName" value="Shellie">
<button onclick="document.querySelector('#nameTag3').innerText=document.querySelector('input[name=name3newName]').value;">Update</button>
</p>

<script>
var shadow = document.querySelector('#nameTag3').webkitCreateShadowRoot();
var template = document.querySelector('#nameTag3Template');
shadow.appendChild(template.content);
template.remove();
</script>

<div class="helperimg" style="display:none;">
    <p>您的浏览器不支持Shadow DOM，这个例子的正确样子是这样的：</p>
    <p><img alt="不支持shadow dom的同学看这个图片" src="/images/shadow_dom_101_4.png" /></p>
</div>

<blockquote>
  <p><a href="http://www.flickr.com/photos/mikedowman/5621169045/">背景图来自Mike Dowman</a>，在Creative Commons授权下使用。</p>
</blockquote>

<p>这相对于现在的web开发状况来说，是一个巨大的进步，因为用于更新名字的代码只需要依赖简单而且一致的组件结构即可，这些代码不需要知道用来做渲染的结构。具体到渲染细节上，名字出现在“Hi! My name is”之后，出现在日语之前，但对于更新名字的代码来说，这些细节都是毫无语义的，因此这些代码完全没有必要知道这些细节。</p>

<h2>高级投影</h2>

<p>在上面的例子中，<code>&lt;content&gt;</code>元素所在的位置放入了所有来自shadow host的元素（副本）。如果使用<code>select</code>属性，则可以选择性地进行投影。你甚至可以使用多个<code>content</code>元素。</p>

<p>比如，如果你的文档中结构是这样：</p>

<pre><code>&lt;div id="nameTag"&gt;
    &lt;div class="first"&gt;Bob&lt;/div&gt;
    &lt;div&gt;B. Love&lt;/div&gt;
    &lt;div class="email"&gt;bob@&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>还有一个shadow root，它使用CSS选择器来指定内容：</p>

<pre><code>&lt;div style="background: purple; padding: 1em;"&gt;
    &lt;div style="color: red;"&gt;
        &lt;content select=".first"&gt;&lt;/content&gt;
    &lt;/div&gt;
    &lt;div style="color: yellow;"&gt;
        &lt;content select="div"&gt;&lt;/content&gt;
    &lt;/div&gt;
    &lt;div style="color: blue;"&gt;
        &lt;content select=".email"&gt;&lt;/content&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<blockquote>
  <p>注意：<code>select</code>属性只可以选择shadow host节点的近亲节点（immediate children），也就是说，你不能选择后代（如<code>select="table tr"</code>）。</p>
</blockquote>

<p><code>&lt;div class="email"&gt;</code>同时被<code>&lt;content select="div"&gt;</code>和<code>&lt;content select=".email"&gt;</code>元素匹配。那么Bob的email地址会出现几次呢？是什么颜色呢？</p>

<p>答案是：Bob的email地址只会出现一次，是黄色的。</p>

<div id="nameTag4">
    <div class="first">Bob</div>
    <div>B. Love</div>
    <div class="email">bob@</div>
</div>

<p><template id="nameTag4Template"></p>

<div style="background: purple; padding: 1em;">
    <div style="color: red;">
        <content select=".first"></content>
    </div>
    <div style="color: yellow;">
        <content select="div"></content>
    </div>
    <div style="color: blue;">
        <content select=".email"></content>
    </div>
</div>

<p></template></p>

<script>
var shadow = document.querySelector('#nameTag4').webkitCreateShadowRoot();
var template = document.querySelector('#nameTag4Template');
shadow.appendChild(template.content);
template.remove();
</script>

<div class="helperimg" style="display:none;">
    <p>您的浏览器不支持Shadow DOM，这个例子的正确样子是这样的：</p>
    <p><img alt="不支持shadow dom的同学看这个图片" src="/images/shadow_dom_101_5.png" /></p>
</div>

<p>原因是，构建在屏幕上渲染的DOM树就像是一场盛大的聚会。<code>content</code>元素是邀请的发起者，它们希望文档中的内容可以进入到Shadow DOM中进行渲染的聚会。这些邀请是按顺序送达的，谁能收到邀请取决于地址上写了谁（即<code>select</code>属性）。对于内容来说，一旦接到邀请，就会立刻接受这个邀请，欣然赴宴。如果下一个邀请被送到了同样的地址，这时候，这个地址已经没有人了，所以它不会出现在聚会中。</p>

<p>在上面的例子中，<code>&lt;div class="email"&gt;</code>同时匹配了<code>div</code>选择器和<code>.email</code>选择器，但因为<code>div</code>选择器来得更早一些，所以<code>&lt;div class="email"&gt;</code>去了黄色的聚会，而没有人去蓝色的聚会。</p>

<p>如果有部分内容没有收到任何邀请，它们将不会被渲染。第一个例子中的“Hello, world”就是这样的情况。这种情况在你想要做一些渐进增强的渲染时很有用：在文档中写入语义化的模型，它可以被脚本获取，然后在渲染时将它隐藏，使用Shadow DOM中的渲染模型来代替它。</p>

<p>比如，HTML中有一个很好用的日历选择控件，如果你用<code>&lt;input type="date"&gt;</code>就能看到一个很不错的弹出日历框。但如果你想让用户选择一个日期范围会是什么情况？你在文档中写下这样的结构：</p>

<pre><code>&lt;div class="dateRangePicker"&gt;
    &lt;label for="start"&gt;Start:&lt;/label&gt;
    &lt;input type="date" name="startDate" id="start"&gt;
    &lt;br&gt;
    &lt;label for="end"&gt;End:&lt;/label&gt;
    &lt;input type="date" name="endDate" id="end"&gt;
&lt;/div&gt;
</code></pre>

<p>然后使用Shadow DOM创建了一个日历表格（译注：不是指datepicker中的日历，而是类似Google日历一样的表格），这个日历表格会高亮选中的日期范围。当用户点击日历表格中的日期时，组件会更新startDate输入框和endDate输入框的值，当用户提交表单时，这两个输入框中的值会被提交。</p>

<p>那么，为什么在文档中还要包含<code>label</code>呢，它们根本不会被渲染？原因就是，如果用户在使用一个不支持Shadow DOM的浏览器，这个表单仍然是可用的，只是没那么完美。用户将会看到类似下面这样的表单：</p>

<div class="dateRangePicker">
    <label for="start">Start:</label>
    <input type="date" name="startDate" id="start">
    <br>
    <label for="end">End:</label>
    <input type="date" name="endDate" id="end">
</div>

<h2>恭喜完成Shadow DOM入门</h2>

<p>这些就是Shadow DOM最基础的内容，恭喜你已经入门了！你可以使用Shadow DOM做更多事情，比如你可以在一个shadow host上挂多个Shadow DOM子树，或者在封装过程中将Shadow DOM嵌套起来，或者使用MDV（Model-Driven Views）和Shadow DOM来构造你的页面。事实上，Web组件远不止Shadow DOM这一门技术，比如，如果使用Web组件规范中的自定义元素部分，你可以使用声明式的方式来初始化Shadow DOM，而不必使用脚本。</p>

<p>我们将在稍后的课程中讲述这些内容。现在，<a href="https://plus.google.com/103330502635338602217/posts">来Google+加入我们吧</a>。</p>

<blockquote>
  <p>原文地址<a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/?redirect_from_locale=zh">http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/?redirect_from_locale=zh</a></p>
</blockquote>

<script>
    var css = document.createElement('link');
    css.setAttribute('rel','stylesheet');
    css.setAttribute('href','/attachments/shadow_dom_101_style.css');
    document.head.appendChild(css);

    if(!window.WebKitShadowRoot){
        $('.helperimg').css({

            border:'1px solid #ccc',
            background:'#eee',
            padding:'20px'

        }).show();
    }
</script>
        ]]>
      </description>
    </item>
    <item>
      <title>JLint——一个sublime的JSLint插件</title>
      <link>http://www.toobug.net/article/jlint_a_jslint_plugin_of_sublime.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/jlint_a_jslint_plugin_of_sublime.html</guid>
      <pubDate>Thu, 13 Dec 2012 12:50:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>先上地址：<a href="https://github.com/TooooBug/JLint">https://github.com/TooooBug/JLint</a></p>

<h3>为什么又造轮子？</h3>

<p>Sublime Text 2是一款非常优秀的代码编辑器，前两天出于对它的喜爱，购买了license，从此走上正版的道路。</p>

<p>恰逢最近在项目中看到了一些不是太好的前端代码，就想弄一个JSLint来辅助检查修改一下。在<a href="http://wbond.net/sublime_packages/community#sort-installs">http://wbond.net/sublime_packages/community#sort-installs</a>上搜索“JSLint”，可以找到三个插件，第一个甚至有2%的用户安装了。但是，仔细看去，这三个插件不是要依赖node就是要依赖java，这让我这种有系统洁癖的人觉得非常不爽。</p>

<p>在找了大半天找不到的情况下，一个想法冒出来了——“逼我么？”</p>

<p>于是有了这个插件。</p>

<h3>说明</h3>

<p>因为是业余作品，花的时间相当少，加之既没有python基础，也不会sublime text插件的开发，全部是现学现卖，因此质量上还有不少问题。</p>

<p>第一个问题是我还不知道如何去打开sublime text 2的控制台，所以在检查完以后需要手工按ctrl+`打开控制台才能看到结果。</p>

<p>第二个问题是不了解其它系统是否有自带的js引擎，所以目前仅支持windows。</p>

<p>第三个问题是windows的脚本宿主（JScript）对连续空行的判断有bug，导致代码中遇到空行后显示的行数不正确。这个坑爹的问题连JSLint作者老道也不准备再搞了，悲剧。</p>

<p>第四个问题是现在代码是同步执行的（还不会搞python子线程的异步执行），文件比较大时会有明显的卡顿现象。</p>

<p>第五个问题是对JSLint的选项还不熟，因此不知道如何配置才最符合工程中的代码要求，这一点我也会自己一边用一边调整。</p>

<h3>结束</h3>

<p>没有了，慢慢改进吧，Node的出现极大地丰富了前端工具，但对不装Node的人来说，还是希望能多一些无依赖的插件可以使用，我也会慢慢去整理一些。</p>
        ]]>
      </description>
    </item>
    <item>
      <title>你好，Solo &amp; GitHub!</title>
      <link>http://www.toobug.net/article/hello_solo_and_github.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/hello_solo_and_github.html</guid>
      <pubDate>Thu, 16 Aug 2012 18:24:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>曾经，有一部电影，名叫Solo（独行者）。其实情节很俗套，无非是生物科技发达，让人死而复生，变成“机器人”一样去打仗，同样俗套的是后面必须会有伦理的斗争，Solo获得意识，而类似的实验被终止。不过，令我一直念念不忘的是它的名字，Solo——独行者。</p>

<p>初中行将毕业时，因为一些突如其来的事情，突然觉得整个世界失去了色彩。那时候真切地觉得，别人都好好活着，我好好地看着就好了。那时候，也曾在心底暗暗标榜过，我的生活，无非是冷眼看世界而已。大半夜在教室睡不着的时候，偶尔也会想想人生。偶尔也会不经意地想到Solo，很好的名字，一个人的精神世界，也许并没有那么糟。</p>

<p>大学进了乐团，终于知道，原来solo还有独奏的意思。那时候跟着一堆朋友们在乐队中瞎混，觉得能抢到一段solo来让自己演奏真的是莫大的荣幸。也是这段经历，让我知道，solo很精彩，solo不孤单。</p>

<p>好了，说了这么多无关痛痒的话题，我只想说，当我看到solo成为一个喜爱的博客项目的名字的时候，打心眼里感到喜悦！于是，来不及想作者的意图到底是本地编译还是在线编译，来不及看代码中的七牛到底是个什么神秘玩意，我就迫不急待地开始了我的solo之旅行。</p>

<p>我很庆幸我是做前端的，这样，在第一眼就看出这个项目有很多不完善的时候，仍然有信心去将它打造成我想要的样子。于是，你看到了你现在看到的博客。当然，它不完美，它离我的预想还有很远，但是我坚信总有一天它会让我满意的。</p>

<p>在接触了MarkDown之后，觉得抛弃WordPress是件很自然的事情了。虽然solo没有后台、没有任何动态特性，但对它每个角落的每一行代码完完全全地掌握就足够让我欣喜，而MarkDown对文字中每个细节的把握更是让我觉得完美，这种喜爱的感觉，奇妙得难以言表。</p>

<p>虽然我有两个VPS，但是仍然选择将solo托管在GitHub上，无他，喜爱而已，就像我对MarkDown的喜爱一样，无可救药。</p>

<p>好了，不扯了。一晃两年没写文字了，再次涉足，手足无措，其实我想说的无非就一句话：我生命中的第三个solo，我来了！</p>
        ]]>
      </description>
    </item>
    <item>
      <title>[译]什么是Shadow Dom？</title>
      <link>http://www.toobug.net/article/what_is_shadow_dom.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/what_is_shadow_dom.html</guid>
      <pubDate>Thu, 07 Jun 2012 18:24:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>如果你做过网站，那么很可能你已经用过一些JavaScript类库。既然如此，你可能会对这些不知名的类库作者心存感激。</p>

<p>这些作者——web开发领域的勇士们——都面对着同样的一个问题——封装。他们会花大量的精力在面向对象的经典问题之一上面，即如何封装自己的代码，以便与类库使用者的代码分离。</p>

<p>除了SVG，现在的Web平台只提供了一种原生的方法去隔离代码块，这并不优雅。没错，我说的就是iframe。对大部分需要封装的场景来说，frames太重而且限制太多。</p>

<p>如果我需要把每个自定义的按钮都放到iframe里，你是什么感觉，会不会疯掉？</p>

<p>所以，我们需要一些更好的东西。事实上，大部分的浏览器已经变相地提供了一种强大技术去隐藏一些实现细节。这个技术就是所谓的“shadow DOM”。</p>

<h3>我的名字是DOM，Shadow DOM</h3>

<p>Shadow DOM是指浏览器的一种能力，它允许在文档（document）渲染时插入一棵DOM元素子树，但是这棵子树不在主DOM树中。看一个简单的slider：</p>

<pre><code>&lt;input id="foo" type="range"/&gt;
</code></pre>

<p>把这段代码放到webkit内核的浏览器中，它会这样显示：</p>

<p><img src="../images/what_is_shadow_dom_1.png" alt="slider" title="" /></p>

<p>很简单吧，这里有一个滑槽，还有一个滑块可以沿滑槽滑动。</p>

<p>嗯。一切看起来都那么美好，喝杯咖啡先……等下等下，这里居然有一个可以在input元素中滑动的元素！为什么我不能通过JavaScript看到它？</p>

<pre><code>var slider = document.getElementsById("foo");
console.log(slider.firstChild); // 返回 null
</code></pre>

<p>这是一种魔法么？</p>

<p>我的观点来看，不是。这只是shadow DOM在起作用。你看，浏览器的开发者们已经意识到了手工编写这些DOM元素的表现和行为很困难而且很SB。所以，从一定程度上讲，他们骗了我们，给了我们一个输入框，但拥有比输入框更多的功能。</p>

<p>他们为你——web开发者设定了一个边界，界定了哪些是你可以访问的，哪些实现细节是访问不到的。然而，浏览器本身却可以随意跨越这个边界。设置这样一个边界之后，它们就可以在你看不见的地方使用熟悉的web技术、同样的HTML元素去创建更多的功能，而不是像你一样要在页面上用div和span来堆。</p>

<p>有一些很简单，就像上面说的slider。而有一些却相当复杂。我们来看一下video元素，它有一些按钮、进度条、hover态的音量控制，像这样：</p>

<p><img src="../images/what_is_shadow_dom_2.png" alt="slider" title="" /></p>

<p>所有的这一切都只是HTML和CSS——但是是隐藏在shadow DOM子树中的。</p>

<p>借用XXX的一首诗，“它是怎样工作的？”为了直观一些，我们假装可以用JavaScript操作它。看这个简单的页面：</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;style&gt; p { color: Green; } &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;My Future is so bright&lt;/p&gt;
&lt;div id="foo"&gt;&lt;/div&gt;
&lt;script&gt;
    var foo = document.getElementById('foo');
    // 注意：这里只是模拟，不是真实的API
    foo.shadow = document.createElement('p');
    foo.shadow.textContent = 'I gotta wear shades';
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>我们获得了一个这样的DOM树：</p>

<pre><code>&lt;p&gt;My Future is so bright&lt;/p&gt;
&lt;div id="foo"&gt;&lt;/div&gt;
</code></pre>

<p>但是它像是被这样渲染出来的：</p>

<pre><code>&lt;p&gt;My Future is so bright&lt;/p&gt;
&lt;div id="foo"&gt; &lt;!-- shadow subtree begins --&gt;
    &lt;p&gt;I gotta wear shades&lt;/p&gt;
&lt;/div&gt; &lt;!-- shadow subtree ends --&gt;
</code></pre>

<p>看起来是这样：</p>

<p><img src="../images/what_is_shadow_dom_3.png" alt="slider" title="" /></p>

<p>注意一下，为什么渲染的句子的第二部分不是绿色的？这是因为文档（document）中选择器p不能获取到shadown DOM。很酷对不对？！如果一个框架开发者被赋予这样的能力会怎么样？想象一下你只需要写你的widget，而不用担心被不知哪里蹦出来的选择器愚弄……简直令人陶醉。</p>

<h3>事件的情况</h3>

<p>为了保持自然，shadow DOM子树中的事件可以在文档（document）中被监听。比如，你点击一下audio元素中的静音按钮，你可以在一个包裹它的div中监听到这个事件。</p>

<pre><code>&lt;div onclick="alert('who dat?')"&gt;
    &lt;audio controls src="test.wav"&gt;&lt;/audio&gt;
&lt;/div&gt;
</code></pre>

<p>但是，如果你要确认事件的来源，会发现它是audio元素，而不是它内部的按钮。</p>

<pre><code>&lt;div onclick="alert('fired by:' + event.target)"&gt;
    &lt;audio controls src="test.wav"&gt;&lt;/audio&gt;
&lt;/div&gt;
</code></pre>

<p>为什么这样？因为当事件穿过shadown DOM边界的时候，会被重新设定target，以避免暴露shadow DOM子树内部结构。用这种方式，你可以监听到从shadow DOM中产生的事件，而实现者也可以继续隐藏细节。</p>

<h3>通过CSS访问（Reaching into）Shadow</h3>

<p>另一个需要提到的技巧是怎样通过CSS来访问shadow DOM子树。假设我想自定义我的slider。我想让它有一些样式，而不是系统原生的那样，像这样：</p>

<pre><code>input[type=range].custom {
    -webkit-appearance: none;
    background-color: Red;
    width: 200px;
}
</code></pre>

<p>结果如下：</p>

<p><img src="../images/what_is_shadow_dom_4.png" alt="slider" title="" /></p>

<p>很好，但是我怎样定义滑块的样式呢？我们已经知道，常规的CSS选择器并不能获取到shadow DOM子树。但事实上，这里有一些很方便的伪元素，可以取到shadow DOM子树中的元素。例如，slider中的滑块在webkit中可以这样访问：</p>

<pre><code>input[type=range].custom::-webkit-slider-thumb {
    -webkit-appearance: none;
    background-color: Green;
    opacity: 0.5;
    width: 10px;
    height: 40px;
}
</code></pre>

<p>样子如下：</p>

<p><img src="../images/what_is_shadow_dom_5.png" alt="slider" title="" /></p>

<p>很完美对不对？想想看，你可以为shadow DOM子树中的元素赋予样式，而不需要真的访问到这些元素。而这些shadow DOM的作者有了决定哪些部分可以被赋予样式的权利。如果你是作者，在做一些UI widget toolkit的时候，难道不想有这样的能力吗？</p>

<h3>带有洞（hole）的Shadow DOM，无穷的想象力</h3>

<p>讲完了这些令人惊叹的能力，我们想象一样，如果给一个有shadown DOM子树的元素插入子元素会怎样？我们来实验一下：</p>

<pre><code>// Create an element with a shadow DOM subtree.
var input = document.body.appendChild(document.createElement('input'));
// Add a child to it.
var test = input.appendChild(document.createElement('p'));
// .. with some text.
test.textContent = 'Team Edward';
</code></pre>

<p>结果如下：</p>

<p><img src="../images/what_is_shadow_dom_6.png" alt="slider" title="" /></p>

<p>哇！欢迎来到twilight DOM的世界！它是文档（document）的一部分，可以被遍历到，但是不会渲染！它是不是很有用呢？不一定，但是如果你需要的话它确实就在那等你。</p>

<p>但是，如果我们真的有能力把元素的子元素放入shadow DOM子树中会怎么样？想象一下shadow DOM是一个模板，通过它的某个洞（hole）可以看到内部的子元素：</p>

<pre><code>// 注意：这里只是模拟，不是真实的API
var element = document.getElementById('element');
// 创建shadow DOM子树
element.shadow = document.createElement('div');
element.shadow.innerHTML = '&lt;h1&gt;Think of the Children&lt;/h1&gt;' +
    &lt;div class="children"&gt;{{children-go-here}}&lt;/div&gt;';
// Now add some children.
var test = element.appendChild(document.createElement('p'));
test.textContent = 'I see the light!';
</code></pre>

<p>如果你去遍历DOM，你会看到这个：</p>

<pre><code>&lt;div id="element"&gt;
    &lt;p&gt;I see the light&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>但是像是这样渲染出来的：</p>

<pre><code>&lt;div id="element"&gt;
    &lt;div&gt; &lt;!-- shadow tree begins --&gt;
        &lt;h1&gt;Think of the Children&lt;/h1&gt;
        &lt;div class="children"&gt; &lt;!-- shadow tree hole begins --&gt;
            &lt;p&gt;I see the light&lt;/p&gt;
        &lt;/div&gt; &lt;!-- shadow tree hole ends --&gt;
    &lt;/div&gt; &lt;!-- shadow tree ends --&gt; 
&lt;/div&gt;
</code></pre>

<p>当你添加子元素的时候，从DOM树中看像一个正常的子元素，但是渲染的时候，他们从“洞（hole）”中进到了shadow DOM子树。</p>

<p>写到这里，你应该会承认，这真的很酷，也会问：</p>

<p>浏览器中什么时候才会有呢？</p>

<h3>家庭作业</h3>

<p>你认为听完了这么多说教的内容会没有家庭作业？作为一个JavaScript类库或者框架的开发者，尝试者去想象一下你可以利用shadow DOM制作的跟之前不一样的伟大的东西。然后想一下shadow DOM可以应用到的一些特定的使用场景（加上真实的或者模拟的代码）。</p>

<p>最后，共享你想到的使用场景到public-webapps邮件列表。关于在web平台中加入这种能力的讨论正在进行，我们需要你的帮助。</p>

<p>如果你不是一个框架作者，你仍然可以参与进来，你可以给shadown DOM加油，也可以将这份快乐传播到你最喜欢的社交网络上，因为快乐就是我们工作的全部。</p>

<p>附：SVG和shadow DOM</p>

<p>差点忘了，至于你信不信，我反正信了，SVG确实已经用到了shadow DOM，从一开始就是这样。但是比较麻烦的是，SVG的shadow DOM非常……非常……水（shady），不不，不是这个词，是另一个词，以sh开头，以y结尾。（注：对英文语境不是太熟悉，评论中有人提到是shy。）对对，就是它！我可以继续说，但是请相信我对SVG shadow DOM的评价。或者你可以查看文档。</p>

<p>原文地址：<a href="http://glazkov.com/2011/01/14/what-the-heck-is-shadow-dom/">http://glazkov.com/2011/01/14/what-the-heck-is-shadow-dom/</a></p>

<p>译者注：应该说这是一篇关于前端理论的文章，并不能给前端开发人员带来什么便利，至少短期内没有，但是了解这种技术对我们从事web相关的软件开发会有好处，而且指不定哪天这种开发模式就出现了呢！</p>

<blockquote>
  <p>2013年5月24日更新：修正了一下之前翻译不通的地方。另外Chrome 23+已经实现了Shadow Dom，Chrome 25+已经默认打开了Shadow Dom的使用选项。因此，现在可以有一些更具体的案例可以看了，比如<a href="https://github.com/TooooBug/shadowDatePicker">https://github.com/TooooBug/shadowDatePicker</a>。近期我也会再写一写Shadow Dom的具体实现方式以及需要注意的地方，敬请关注！</p>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>jSound Alpha</title>
      <link>http://www.toobug.net/article/jsound_alpha.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/jsound_alpha.html</guid>
      <pubDate>Fri, 06 Apr 2012 12:27:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>某天突发奇想，咋没有一个关于声音的js库？本来HTML5的声音就很弱，这方面应该有更多的封装才适合做游戏之类的东东。</p>

<p>在网上找了一下，有个叫<a href="https://github.com/nicklockwood/SoundManager">soundmanager</a>的库，不过它是调用flash的声音能力，当然功能也比较强大。</p>

<p>于是就自己写了一个，目前还只是最最简单的版本，全部代码如下：</p>

<pre><code>~function(w){
    if(w.jSound)return;
    ~function(){
        if (!document.body){
            setTimeout(arguments.callee,50);
            return;
        }
        var elem = document.createElement('audio'),src;
        if (!elem.canPlayType){
            elem = document.createElement('bgsound');
        }
        document.body.appendChild(elem);
        w.jSound={
            play:function(soundSrc){
                src=soundSrc;
                elem.src='';
                elem.src=src;
                if (elem.canPlayType){
                    elem.play();
                }
            }
        }
    }();
}(window);
</code></pre>

<p>目前只是封装了IE与非IE的差别，IE下用bgsound，非IE用audio标签，还有比较多的事情要解决：</p>

<ul>
<li>声音重叠（IE下必须播放完后才能重新放同一个声音，即使将src赋空后重新赋值也不行）</li>
<li>URL请求，目前每点击一次在高级浏览器下会发出两个HTTP请求，原因还没仔细去看，后续看看能否优化成下载后不再发出请求</li>
<li>多声音管理，本来刚开始是将jSound写成构造函数的，然后每个对象管理自己的src和页面元素elem，但是试用了一下觉得似乎不太必要又改为了现在全局对象的样子，是否需要单独的对象要再衡量一下</li>
<li>播放状态管理，这个估计有困难</li>
</ul>

<blockquote>
  <p>8月17日更新：已经开源到<a href="https://github.com/TooooBug/jSound">GitHub</a>，另外许久未打理，估计得过段时间再继续完善。</p>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>HTML续行符</title>
      <link>http://www.toobug.net/article/the_line_continuation_of_html.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/the_line_continuation_of_html.html</guid>
      <pubDate>Wed, 01 Feb 2012 18:04:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>常识：</p>

<ol>
<li>HTML源码中夹在文字中连续的空白（空格、回车、TAB等）会在页面上形成一个空格</li>
<li>大部分的代码规范会规定单行不得超过XX字符，超过必须做折行处理</li>
<li>CSS可以按属性多行编写，JS的长字符串可以用“\”续行</li>
</ol>

<p>问题：HTML的长字符串怎么办？</p>

<p>答案：使用注释</p>

<p>例：</p>

<pre><code>这是源码中的第一行文字，它很长，以至于达到了要折行的要求&lt;!--
--&gt;接着写第二，不管它有多长都不怕了，因为在页面中，始终是&lt;!--
--&gt;当成同一行处理。
</code></pre>

<blockquote>
  <p>2012年8月17日注：这种用法除了是因为规范外，还有一个原因，就是消除inline-block带来的间隙，详见<a href="http://ued.taobao.com/blog/2012/08/15/inline-block/">inline-block的前世今生</a>。</p>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>IE7下focus方法失效（原因不明）</title>
      <link>http://www.toobug.net/article/ie7_focus_method_invalid.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/ie7_focus_method_invalid.html</guid>
      <pubDate>Wed, 28 Dec 2011 10:49:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>项目中遇到一个诡异的问题：用jQuery写的一个click事件响应中，一个输入框的focus()方法无效，仅在IE7下出现。</p>

<p>在IE的调试工具中，手工执行focus没有问题，不管是jQuery对象的focus方法还是DOM的focus的方法都可以正常工具，但是放到响应事件中就不行。</p>

<p>断点调试、打log也没什么结果，代码是走到那里了，但是input就是死活不focus。</p>

<p>后来死马当活马医，开始试。结果发现将focus方法连续调用两次，居然生效了。</p>

<p>原因不明，期待高人解释。</p>
        ]]>
      </description>
    </item>
    <item>
      <title>《Javascript Patterns》读书笔记 第二章 概要（1）</title>
      <link>http://www.toobug.net/article/javascript_patterns_note_chapter_2.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/javascript_patterns_note_chapter_2.html</guid>
      <pubDate>Sat, 24 Dec 2011 18:34:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>这一章概要地介绍了一些最佳实践、模式还有编码习惯。</p>

<h3>一、编写可维护的代码</h3>

<p>发现bug时最好能立马修复，延迟可能导致你需要更多的时间去重新理解问题，还有可以解决问题的代码。</p>

<p>代码经常会被阅读，因为以下原因：</p>

<ol>
<li>Bugs</li>
<li>新功能要添加</li>
<li>程序需要在新环境下运行</li>
<li>代码的功能被改变</li>
<li>代码完全被重写</li>
</ol>

<p>可维护的代码表示代码具有以下特性：</p>

<ol>
<li>可读的</li>
<li>一致的</li>
<li>可预测的</li>
<li>看起来像同一个人编写的</li>
<li>有文档的</li>
</ol>

<h3>二、尽量减少全局变量</h3>

<p>JavaScript用函数来管理作用域，函数内定义的变量是局部的。全局变量是定义在任何函数之外的或者是未定义直接使用的变量。</p>

<p>每个JavaScript有一个全局对象（global object），当this用在任何函数之外时可以访问到它。每个全局变量成为全局对象的一个属性，游戏器中全局对象是window。</p>

<p>全局变量的问题在于它被所有的代码共享，当两部分的代码定义相同的全局变量时，会产生冲突。</p>

<p>引入一个第三方的代码也是很常见的，比如：</p>

<ol>
<li>第三方库</li>
<li>来自广告伙伴的脚本</li>
<li>来自流量跟踪和分析的代码</li>
<li>各种widget等</li>
</ol>

<p>当一个第三方脚本定义了全局变量result后，你自己定义的函数定义全局变量result时就会覆盖前面的全局变量。</p>

<p>所以和其他的脚本共同工作时，减少全局变量的使用是非常重要的。使用var定义变量是一个最重要的方法。</p>

<p>提示：另一个减少全局变量使用的原因是考虑到可移植性，当你的代码要运行在不同的环境中时，定义全局变量是很危险的，因为可以覆盖来自宿主的全局变量。</p>

<p>用var创建的全局变量和未使用var创建的隐性全局变量有一点细微的差别：</p>

<p>用var创建的全局变量不能被delete删除，而未使用var创建的隐性全局变量可以用delete删除。</p>

<p>在ES5“严格模式”下，给未定义的变量赋值将报错。</p>

<h3>三、访问全局对象</h3>

<p>在浏览器中，全局对象可以在任何代码中通过window访问。但在另一些环境中，这个全局对象可能叫不同的名字，所以最好不要硬编码，而是通过下面的代码访问（在任何代码中都可以）：</p>

<pre><code>var global = (function(){
    return this;
}());
</code></pre>

<p>(注：最外层的括号完全可以不要的，括回也可以放到最后一对空括号之前)</p>

<h3>四、单var语句</h3>

<p>在函数开头只使用一个var语句有如下好处：</p>

<ol>
<li>变量集中到开头</li>
<li>阻止当一个变量在声明前使用时产生逻辑错误（hoisting，见后文）（注：这个是指JavaScript预编译机制导致的变量可见性问题，即一个变量在同一作用域内先读，后定义，则读的时候会是undefined，而不管它的作用域链中同名变量情况是如何）</li>
<li>强迫记得声明变量，减少隐性全局变量</li>
<li>减少代码量</li>
</ol>

<p>声明变量时赋初值是个好习惯，可能避免逻辑错误，并增加代码可读性，可以一眼看出是什么类型的变量。</p>

<p>你也可以在定义的时候做真正的计算。（注：例子中是指一系列逗号分开的定义中，后面的变量可以使用前面的变量）</p>

<p>JavaScript允许在函数内部随意、多次使用var定义变量，就跟在顶部定义一样的效果，这个行为叫hoisting（注：不知该如何翻译好）。如：</p>

<pre><code>myname="global";
function func(){
    alert(myname);    //"undefined"
    var myname="local";
    alert(myname);    //"local"
}
func();
</code></pre>

<p>跟下面的代码一样，好像定义被提前了一样：</p>

<pre><code>myname="global";
function func(){
    var myname;
    alert(myname);    //"undefined"
    myname="local";
    alert(myname);    //"local"
}
func();
</code></pre>

<blockquote>
  <p>提示：在理解的时候，可以将函数和变量定义理解为“提前”，但ECMAScript中并未有这种说法。在实现的时候，其实是分两步的，第一步先扫描函数和变量定义，创建上下文环境（context），第二步才执行代码。</p>
  
  <p>第二章内容好多，先发一部分，之后继续。</p>
  
  <p>2012年8月20日更新：短期内可能不会更新了，本书正在翻译中，<a href="https://github.com/TooooBug/javascript.patterns">翻译稿</a>可以在GitHub上找到。</p>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>The Little Book on Coffee Script</title>
      <link>http://www.toobug.net/article/the_little_book_on_coffee_script.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/the_little_book_on_coffee_script.html</guid>
      <pubDate>Fri, 23 Dec 2011 18:14:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>最近突然对基于JS的编译语言有了兴趣，分别看了一下Dart和Coffee Script。但是Dart的虚拟机（js文件）高达10M的体积确实让人后怕，本机用chrome都会卡好久，只能期待chrome加入原生虚拟机的表现了。</p>

<p>而coffee script似乎也是一门比较吃香的语言，官方更新也非常快，据说语法和功能和ruby很像。</p>

<p>扫了一眼官方推荐的第一本书，但是是网页的，花了点时间整理成PDF了，方便自己看。</p>

<p>顺便也发到博客上，有需要的同学可以看看。</p>

<p><a href="../attachments/The-Little-Book-on-Coffee-Script.pdf">The Little Book on Coffee Script</a></p>
        ]]>
      </description>
    </item>
    <item>
      <title>IE下绝对定位的链接display:block失效的问题</title>
      <link>http://www.toobug.net/article/ie_position_absolute_link_display_block_invalid.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/ie_position_absolute_link_display_block_invalid.html</guid>
      <pubDate>Wed, 21 Dec 2011 20:02:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>IE下如果a元素使用绝对定位，在没有背景的情况下，display:block会失效。</p>

<p>搜索了一下，解决方案在这里：</p>

<p><a href="http://firefly365.com/question/css/201011052110376846.html">http://firefly365.com/question/css/201011052110376846.html</a></p>

<p>大意是添加背景就好了，如果要保持透明，则添加透明图片做背景，或者是用url(about:blank)做背景。</p>

<p>我在试验的时候发现，如果a包含在div当中，如果div有背景，也同样可以让链接生效。</p>

<p>想来想去，这个东西只可能是bug，要具体解释会涉及到IE的原理，超出能力范围。</p>
        ]]>
      </description>
    </item>
    <item>
      <title>Chrome也支持zoom了</title>
      <link>http://www.toobug.net/article/chrome_supports_zoom.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/chrome_supports_zoom.html</guid>
      <pubDate>Wed, 21 Dec 2011 19:59:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>查阅网上的中文资料，几乎每篇文章都在说，zoom是IE专有的属性，但事实是，chrome也支持。</p>

<p>Demo：<a href="http://jsfiddle.net/toobug/9drpy/1/embedded/result/">http://jsfiddle.net/toobug/9drpy/1/embedded/result/</a></p>

<p>所以在chrome下放大元素除了用css3之外，也可以用zoom这样简单的方法了。</p>

<blockquote>
  <p>2013-07-20更新1：现在网上再查已经可以查到有很多资料在讲chrome支持zoom属性了。顺带提一下，CSS3中用transform的写法：<code>transform:scale(0.5);</code>，但这个缩放是以中心点为原点来进行的，可以通过<code>transform-origin:top left</code>来修正。</p>
  
  <p>2013-07-20更新2：在IE中zoom被用于激活hasLayout属性的作用远大于它本身的缩放作用。但事实上，zoom在进行缩放时，部分低版本IE下（比如IE7）在遇到<code>position:relative</code>的元素时会有各种定位漂移的bug，因此，慎用为好。</p>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>《JavaScript Patterns》读书笔记 第一章 介绍</title>
      <link>http://www.toobug.net/article/javascript_patterns_note_chapter_1.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/javascript_patterns_note_chapter_1.html</guid>
      <pubDate>Sat, 17 Dec 2011 17:29:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>《JavaScript Patterns》(<a href="http://book.douban.com/subject/5252901/">http://book.douban.com/subject/5252901/</a>)是一本关于JavaScript的设计模式的书，它抛弃了其他同类书籍“一定要完全模拟面向对象”的思路，而是从一个更高的层次，即设计模式解决了什么问题入手，对每种模式进行细致的分析，然后从JavaScript本身的特性出发去进行实现，写得非常不错。</p>

<p>这本书目前还没有中文版，据说淘宝UED的大牛们正在翻译。</p>

<p>以下为读书笔记，中文为本人根据意思大致整理，不保证完全跟原文一样准确。</p>

<h3>第一章 介绍</h3>

<p>广义上的“模式”指“重复的事件或对象的主题……它可以是一种通用的模板或者模型”</p>

<p>在软件开发中，一种模式就是一类问题的解决方案。一种模式不是指可以复制粘贴的代码，而是一种用来解决一类问题的抽象模板。</p>

<p>了解设计模式很重要，因为</p>

<ol>
<li>可以帮助我们使用已经被实践检验过的模式，不重复造轮子</li>
<li>人脑的思维能力有限，当你思考一个复杂问题，并且注意力不在底层细节时，它能提供一种抽象的模式帮助你</li>
<li>在不同的开发者和团队之间易于交流（注：传说中的“黑话”）</li>
</ol>

<p>这本书讨论了设计模式、编码模式、不好的代码实现（Antipatterns）</p>

<h3>一、面向对象</h3>

<p>JavaScript是一门面向对象语言（注：似乎现在大家都认为它是“基于对象”而非“面向对象”）。</p>

<p>只有五种基本类型不是对象，分别是number,string,boolean,null,undefined
number,string,boolean的值很容易转变成对象，不管是被编程者还是隐式地被JavaScript解释器。</p>

<p>函数也是对象，可以有属性和方法。</p>

<p>定义变量时就在处理对象。首先，变量自动变成一个叫活动对象（或者全局对象）的属性。其次，这个变量实际上很像对象，因为它有自己的属性，决定它是否能被改变，删除或者用for-in遍历。这些属性在ECMAScript3中不是直接暴露的，但是在第5版中提供特别的装饰器手工操作它们。</p>

<p>对象是名值对的集合（和其它语言的关联数组的概念很像）。有的属性值可以是函数，这些函数被叫作方法。</p>

<h3>二、没有类</h3>

<p>在JS中创建对象不需要类，只需要创建它，然后给它添加基本类型、函数或者对象作为属性即可。一个空对象不是真的是空的，它有一些原生的属性，但是它没有自己的（own）属性。</p>

<h3>三、原型</h3>

<p>JavaScript有继承，虽然这只是一种代码复用的方式。继承可以通过多种不同的方式完成，经常会利用到原型。</p>

<p>原型是一个对象，每个由编码者创建的函数都自动有一个指向空对象的原型，这个对象跟使用字面量或者Object()构造函数创建的空对象差不多，除了constructor是指向函数而不是原生的Object()</p>

<h3>四、环境</h3>

<p>JavaScript需要一个环境来运行，最常见的是浏览器，但那不是唯一的环境。</p>

<p>这本书的大部分是讲的JavaScript核心部分，与环境无关。</p>

<p>环境可以提供自己的宿主对象，这是在ECMAScript中没有定义的，可能会有意料之外的行为（注：如浏览器的JS兼容性问题就绝大部分来源于宿主对象的差异）。</p>

<h3>五、ECMAScript5</h3>

<p>JavaScript核心部分基于ECMAScript标准。第三版标准于1999年被官方承认，也是现在各浏览器实现的版本。第四版已经放弃。第五版在2009年发布。</p>

<p>第5版加入了一些原生对象、方法和属性。但是最重要的变化是严格模式（strict mode），这个模式从以前的版本中移除了一些特性，使得编程更简单，减少错误倾向。</p>

<p>严格模式通过一段普通的文本触发，向下兼容。</p>

<p>在一个作用域中（不管是函数作用域、全局作用域，还是传给eval()的字符串的开头），都可以用”user strict”来触发严格模式。</p>

<p>这本书不研究与ES5有关的模式，因为成书时没有浏览器实现了ES5。但是例子中与ES5相关的特性如下：</p>

<ol>
<li>保证提供的代码在严格模式下不报错</li>
<li>避免使用ES5弃用的结构，如arguments.callee</li>
<li>尽量使用ES5中原生的方法（注：在ES3中自己实现，保持名称和参数一样），如Object.create()</li>
</ol>

<blockquote>
  <p>注：后面的JSLint和console，略</p>
  
  <p>2012年8月20日注：目前我正在参与翻译该书，<a href="https://github.com/TooooBug/javascript.patterns">翻译稿</a>可以在GitHub上找到。</p>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>IE下利用Matrix滤镜实现绕中心点旋转</title>
      <link>http://www.toobug.net/article/ie_matrix_rotation.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/ie_matrix_rotation.html</guid>
      <pubDate>Thu, 15 Dec 2011 13:16:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>旋转一个元素算是一个比较常见的需求了吧，在支持CSS3的浏览器中可以使用transform很容易地实现，这里有介绍：<a href="http://www.css88.com/archives/2168">http://www.css88.com/archives/2168</a>，这里有演示<a href="http://www.css88.com/tool/css3Preview/Transform.html">http://www.css88.com/tool/css3Preview/Transform.html</a>，就不再介绍了。</p>

<p>在IE下旋转一个元素，则只能靠滤镜了。</p>

<p>如果只是以90度为单位旋转的话，简单地使用这个滤镜就好：</p>

<pre><code>filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=i)
</code></pre>

<p>其中i取0，1，2，3，分别代表旋转90度、180度、270度、360度。</p>

<p>而如果要实现任意角度旋转，则要使用Matrix（矩阵）滤镜。</p>

<p>网上介绍的方法都是这样：</p>

<pre><code>filter:progid:DXImageTransform.Microsoft.Matrix(M11=m11,M12=m12,M21=m21,M22=m22,sizingMethod="auto expand");
</code></pre>

<p>设旋转角为x，用弧度表示。那么m11=cos(x),m12=-sin(x),m21=sin(x),m22=cos(x)</p>

<p>实测这个方法有效，但是它会绕元素原来轮廓的左边和上边转动，还是画个图示意一下：</p>

<p><img src="../images/ie_matrix_rotation_1.jpg" alt="IE非中心点旋转" title="" /></p>

<p>如图所示，图形会贴着上边和左边旋转。</p>

<p>那如果我们要绕中间点旋转的话要怎么做呢？这就说来话长了，得讲到几何的向量方法。</p>

<p>坐标系中，每个点有一个坐标，比如点p(3,4)，横坐标为3，纵坐标为4。</p>

<p>接下来，向量：简单理解为有方向的线段。</p>

<p>将点和原点连接起来，方向从原点指向点，即构成一个向量op。</p>

<p>通过这样的方式，我们就将向量与点一一映射起来了，研究点的时候就可以用向量来研究啦。</p>

<p><img src="../images/ie_matrix_rotation_2.jpg" alt="点到坐标映射" title="" /></p>

<p>接下来，研究旋转的实质，P点绕原点O（顺时针）旋转角度α，即向量OP旋转α，新的点P‘坐标变为(3<em>cosα-4</em>sinα,4<em>sinα+3</em>cosα).</p>

<p>为什么会是这个值，请参阅<a href="http://zh.wikipedia.org/wiki/%E6%97%8B%E8%BD%AC">http://zh.wikipedia.org/wiki/%E6%97%8B%E8%BD%AC</a>（数学里面以逆时针为正方向，所以公式在符号上略有不同）</p>

<p>上面新坐标中，在原坐标上进行的计算的数cosα,-sinα,sinα,cosα刚好就是上上面IE的matrix中的参数m11,m12,m21,m22！</p>

<p>事实上，上面的计算一般会写成矩阵的方式来进行，见<a href="http://zh.wikipedia.org/wiki/%E6%97%8B%E8%BD%AC">维基百科</a>的表示方法。</p>

<p>所以，matrix滤镜的实质是对图形进行坐标的矩阵运算。</p>

<p>上面说的是绕原点O旋转，如果绕的是非原点呢？情况比较复杂，详见<a href="http://hi.baidu.com/windsion/blog/item/b4a41951699aa0c9b645ae4f.html">http://hi.baidu.com/windsion/blog/item/b4a41951699aa0c9b645ae4f.html</a>。</p>

<p>大致分为三步：</p>

<ol>
<li>整体位移，即把中心点和向量做相应位移，使旋转点变为原点</li>
<li>绕原点旋转，和上面说的一样</li>
<li>整体位移，再将中心点移回原来的地方去</li>
</ol>

<p>这个时候，计算的矩阵就变得复杂了（<a href="http://hi.baidu.com/windsion/blog/item/b4a41951699aa0c9b645ae4f.html">上面文章</a>的最下方）。</p>

<p>而事实上，这个矩阵是可以化简的，详见这里<a href="http://stackoverflow.com/questions/5051451/javascript-ie-rotation-transform-maths">http://stackoverflow.com/questions/5051451/javascript-ie-rotation-transform-maths</a></p>

<p>最终，我们得到除了上面的m11,m12,m21,m22之外的另外两个数，这两个数在IE的matrix滤镜中表示为Dx,Dy。</p>

<p>将这六个参数写入matrix滤镜，即可绕中心点旋转了。</p>

<p>完整的写法：</p>

<pre><code>progid:DXImageTransform.Microsoft.Matrix(Dx=dx,Dy=dy,M11=m11,M12=m12,M21=m21,M22=m22);
</code></pre>

<p>其中</p>

<pre><code>dx=-width/2*cosdeg+height/2*sindeg+width/2,
dy=-width/2*sindeg-height/2*cosdeg+height/2
m11,m12,m21,m22与前面说的一样。
</code></pre>

<p>哦哦，对了，微软官方说了<a href="http://msdn.microsoft.com/en-us/library/ms532872(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/ms532872(v=vs.85).aspx</a>，如果sizingMethod=”auto expand”，那么Dx、Dy是无效的哦。所以去掉就好啦。</p>

<p>最后的最后，sizingMethod是什么意思呢，如果不设它的话，旋转对象的容器大小会是固定的，所以可能有遮挡的情况，自己要调整好大小，而如果它被设为auto expand，就是自动扩展的意思，即旋转时外面的容器大小会自动调整，以便不遮挡正在旋转的元素。</p>
        ]]>
      </description>
    </item>
    <item>
      <title>HTML元素的键盘事件</title>
      <link>http://www.toobug.net/article/keyboard_event_of_html_elements.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/keyboard_event_of_html_elements.html</guid>
      <pubDate>Tue, 06 Dec 2011 16:30:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>这篇文章里已经说得很清楚了：</p>

<p><a href="http://yiminghe.iteye.com/blog/729265">http://yiminghe.iteye.com/blog/729265</a></p>

<p>核心观点是：</p>

<ul>
<li>除了文中列出的元素，其他元素不能直接获得键盘事件，除非通过冒泡</li>
<li>对不能直接获得键盘事件的元素，通过让它强制获得焦点可以响应键盘事件</li>
</ul>

<p>文中没有说到的一点是：document.body,document,window都可以直接响应键盘事件。</p>
        ]]>
      </description>
    </item>
    <item>
      <title>同域iframe“拒绝访问”的问题</title>
      <link>http://www.toobug.net/article/iframe_same_origin_access_denied.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/iframe_same_origin_access_denied.html</guid>
      <pubDate>Thu, 01 Dec 2011 16:57:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>同事项目中用了一个iframe，父页和子页都设置了document.domain进行降域，结果在非IE下正常，IE下“拒绝访问”。</p>

<p>跟大多数人想的一样，iframe遇到“拒绝访问”首先肯定考虑是document.domain的问题，但是这里父子页面都显式做了降域处理，应该不会。找不出其他原因，只好试了一下，结果屏蔽来屏蔽去调了半天，问题依旧。</p>

<p>后来辗转找到了这篇文章<a href="http://www.cnblogs.com/shouzheng/archive/2008/07/07/1237245.html">http://www.cnblogs.com/shouzheng/archive/2008/07/07/1237245.html</a>，终于解决问题。</p>

<p>问题产生的原因是IE的速度比较慢，在iframe还没有加载的时候是访问不到它的contentWindow,contentDocument之类的对象的，所以报“拒绝访问”。解决的办法很简单，加一个轮询，如果iframe的document.readyState == ‘complete’，再进行操作。</p>

<p>猜测：其他的浏览器一定不出问题么？如果加载一个超级大的文件？还是原理不一样？（如果也有同样的问题的话，其它浏览器可以直接监听iframe的onload事件。）</p>
        ]]>
      </description>
    </item>
    <item>
      <title>xheditor从剪贴板粘贴图片的实现原理</title>
      <link>http://www.toobug.net/article/xheditor_paste_images.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/xheditor_paste_images.html</guid>
      <pubDate>Wed, 30 Nov 2011 10:08:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p><a href="http://xheditor.com/">xheditor</a>是一个优秀的国产富文本编辑器，最近的（其实我也不知道有多久了）版本推出了一个粘贴剪贴板图片的功能，很是喜爱，好奇了好久，最终不住去看了下源码，基本明白了。</p>

<p>首先，这个功能很新，不支持IE系列浏览器……用的是一些新的API。我手上的代码是1.1.10，所以代码行数以这个版本为准。</p>

<p>一点前置小知识是必备的，那就是对大部分截图软件来说，截图操作是一个把截取的图片转换成指定格式（windows自带的是bmp）然后放入剪贴板的过程。所以，要粘贴图片，核心就是读取剪贴板。</p>

<h3>一、读取剪贴板的时机</h3>

<p>近几年浏览器在拼标准、拼性能的时候，其实也在暗里拼安全，为了防止某个网页一打开就自动把你剪贴板的内容传网上去（IE6可以做到），现代浏览器不允许随时读写剪贴板。</p>

<p>浏览器为我们提供了onpaste事件（粘贴），读取剪贴板数据仅能在该事件发生时在事件处理程序中进行。因这里理解就好，所以就不贴代码。</p>

<h3>二、图片数据</h3>

<p>之所以IE不能粘贴图片，就在于IE没有处理二进制文件的机制，它只能处理文本。</p>

<p>在现代浏览器中，则有关于文件的API，这里用到的就是File Reader，主要用来处理二进制文件数据。</p>

<p>首先，在xheditor的第1922行，有一个<code>cleanPaste()</code>函数，它的作用就是读取剪贴板的数据，然后放入编辑器中，具体见代码注释。</p>

<pre><code>var clipboardData,items,item;//for chrome

//ev是事件，其实大家都喜欢用e或者evt或者event
//这句主要是确定剪贴板中是否有图片
if(ev&amp;&amp;
    (clipboardData=ev.originalEvent.clipboardData)&amp;&amp;
    (items=clipboardData.items)&amp;&amp;
    (item=items[0])&amp;&amp;item.kind=='file'&amp;&amp;item.type.match(/^image\//i)
){
    var blob = item.getAsFile(),    //blob就是剪贴板中的二进制图片数据
        reader = new FileReader();

    //定义fileReader读取完数据后的回调
    reader.onload=function(){
        var sHtml='&lt;img src="'+event.target.result+'"&gt;';    //result是base64编码后的图片
        //这里执行了一个将base64上报到服务器，然后将图片url从base64编码的图片数据换成上传后的图片地址
        sHtml=replaceRemoteImg(sHtml);
        _this.pasteHTML(sHtml);//这里应该是关于光标和插入代码的具体操作
    }

    reader.readAsDataURL(blob); //用fileReader读取二进制图片，完成后会调用上面定义的回调函数
    return false;
}
</code></pre>

<p>好吧，本来还想写下中间上报到服务器的代码的，想了想觉得也没什么很特别的地方。最多是把base64数据当成普通URL上报，然后服务端再解码成图片。</p>

<p>嗯。就这样，当笔记了。</p>
        ]]>
      </description>
    </item>
    <item>
      <title>《JavaScript语言精粹》读书笔记 第六章 数组</title>
      <link>http://www.toobug.net/article/javascript_the_good_parts_notes_chapter_6.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/javascript_the_good_parts_notes_chapter_6.html</guid>
      <pubDate>Wed, 27 Apr 2011 17:16:00 +0800</pubDate>
      <description>
        <![CDATA[
        <h3>6.0绪</h3>

<p>数组可以是很快的数据结构，但是JS不是这种。</p>

<p>JS提供了一种拥有一些类数组（array-like）特性的对象。把下标转变成字符串作为属性。</p>

<p>比真正的数组慢，但很方便。</p>

<p>检索和更新与对象一模一样，除了可以用整数作为属性名。</p>

<h3>6.1数组字面量</h3>

<p>数组字面量是在一对方括号中包围零个或多个用逗号分隔的表达式。</p>

<p>JS数组允许包含任意混合类型的值！</p>

<h3>6.2长度</h3>

<p>每个数组有一个length，length没有上界，如果用大于或等于当前length的数字作为下标来保存一个元素，length将增大来容纳新元素。</p>

<p>length属性的值是最大整数属性名加1，不一定等于数组里属性的个数！</p>

<p>length可写，设置更大的值无须分配空间（注：貌似，JS数组是”稀疏“的），设置更小的值将删除多的属性。</p>

<h3>6.3删除</h3>

<p>delete numbers[2]可以删除，但是会留下undefined在原位置。</p>

<pre><code>numbers.splice(index,num[,newitem[,newitem...]])
</code></pre>

<p>删除元素，后面的位置前移，如果newitem存在，则插入index。效率不高。</p>

<h3>6.4枚举</h3>

<p>可以用for in，但是顺序无法保证，而且不能排除原型链中的属性。</p>

<p>可以用for循环。</p>

<h3>6.5混淆的地方</h3>

<p>typeof数组是”object”。</p>

<p>typeof null是”object”。</p>

<p>JS没有好的机制区分数组和对象。</p>

<pre><code>var is_array = function(value){
    return value &amp;&amp;
        typeof value === "object" &amp;&amp;
        value.constructor === Array;
}
</code></pre>

<p>这段代码，如果识别从不同的window或者frame里构造的数据就会失败。</p>

<pre><code>var is_array = function(value){
    return value &amp;&amp;
        typeof value === "object" &amp;&amp;
        typeof value.length === "number" &amp;&amp; //对象不一定
        typeof value.splice === "function" &amp;&amp; //所有数组有
        !(value.propertyIsEnumerable("length")); //length不能用for in枚举
}
</code></pre>

<p>（第一行拒绝了null，第三行确定了是数组，为什么要有其他行？对象也可能添加splice方法，也可能添加length属性。）</p>

<h3>6.6方法</h3>

<p>数组添加非数字属性名的属性时，不改变length。</p>

<h3>6.7维度</h3>

<p>JS数组中的属性值为数组，则构成二维数组。</p>

<p>第二维的数组需要自己创建。</p>
        ]]>
      </description>
    </item>
    <item>
      <title>《JavaScript语言精粹》读书笔记 第五章 继承</title>
      <link>http://www.toobug.net/article/javascript_the_good_parts_notes_chapter_5.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/javascript_the_good_parts_notes_chapter_5.html</guid>
      <pubDate>Wed, 27 Apr 2011 17:15:00 +0800</pubDate>
      <description>
        <![CDATA[
        <h3>5.0绪</h3>

<p>JS是一门弱类型语言。对象的起源无关紧要。</p>

<p>在基于类的语言中，对象是类的实例，并且类可以从另一个类继承。JS是一门基于原型的语言，这意味着对象直接从其他对象继承。</p>

<h3>5.1伪类</h3>

<p>函数对象被创建时，Function构造器产生的函数对象会运行类似这样的代码：</p>

<pre><code>this.prototype = {constructor : this};
</code></pre>

<p>prototype对象是存放继承特征的地方。因为JS没有提供方法去确定哪个函数是打算用来作构造器，所以每个函数都会得到一个prototype对象。</p>

<p>constructor属性没什么用，重要的是prototype对象。</p>

<h3>5.2对象说明符</h3>

<p>传参数可以用对象，不用按顺序了。</p>

<h3>5.3原型</h3>

<p>实现继承和差异化继承。</p>

<h3>5.4函数化</h3>

<p>一个将产生对象的函数：</p>

<ol>
<li>创建一个新对象。</li>
<li>定义私有变量和方法。</li>
<li>给对象扩充方法（公有？）。</li>
<li>返回新对象</li>
</ol>
        ]]>
      </description>
    </item>
    <item>
      <title>《JavaScript语言精粹》读书笔记 第四章 函数</title>
      <link>http://www.toobug.net/article/javascript_the_good_parts_notes_chapter_4.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/javascript_the_good_parts_notes_chapter_4.html</guid>
      <pubDate>Wed, 27 Apr 2011 16:53:00 +0800</pubDate>
      <description>
        <![CDATA[
        <h3>4.1函数对象</h3>

<p>在Javascript中函数就是对象。</p>

<pre><code>Function.prototype===Object
</code></pre>

<p>函数创建时有两个隐藏属性：上下文、实现函数行为的代码</p>

<h3>4.2函数字面量</h3>

<p>通过函数字面量创建的函数对象包含一个连到外部上下文的连接–闭包。</p>

<h3>4.3调用</h3>

<p>四种调用模式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式</p>

<p>不同的模式在初始化this上有差异</p>

<p>调用运算符：任何产生函数值（注：似乎应为”函数” ）的表达式后一对圆括号</p>

<p>实参（arguments）与形参（parameters）个数不匹配时不会报错，多的会忽略，少的为undefined。</p>

<p>方法调用模式：一个函数被保存为对象的一个属性时，称为方法，this被绑定到该对象。通过this可取得所属对象上下文的方法称为公共方法。</p>

<p>函数调用模式：一个函数非对象属性，this绑定到全局对象。不会绑定到外部函数的this！</p>

<p>构造器调用模式：JS是原型继承，同时提供了基于类类似的对象构建语法！（即new运算符。 ）</p>

<p>apply调用模式：apply接收两个参数，第一个被绑定给this第二个是参数数组。如</p>

<pre><code>var status = Quo.prototype.get_status.apply(statusObject);
</code></pre>

<p>相当于</p>

<pre><code>statusObject.get_status();
</code></pre>

<p>虽然它没有get_status方法。</p>

<h3>4.4参数</h3>

<p>arguments数组会包含所有实参，包括形参中没有对应的实参。</p>

<p>arguments是一个类数组（array-like），有length属性，缺少所有的数组方法。</p>

<h3>4.5返回</h3>

<p>函数被调用时从第一个语句开始执行，遇到关闭函数体的”}”时结束，控制权交还给调用该函数的语句。return使函数提前返回，不再执行余下语句。</p>

<p>函数总会返回值，如果没有指定，返回undefined。</p>

<p>如果函数以new方式调用，且返回值不是对象，则返回this（新对象 ）。</p>

<h3>4.6异常</h3>

<pre><code>try{
    function();
}catch(e){
    //e
}
</code></pre>

<p>function通过</p>

<pre><code>throw {name:"error",message:"error"};
</code></pre>

<p>抛出exception对象，被catch接住（e）。</p>

<p>一个try只能一个catch。</p>

<h3>4.7给类型增加方法</h3>

<p>JS允许给基本类型增加方法。</p>

<p>增加的方法立刻被赋予到所有对象实例上。</p>

<h3>4.8递归</h3>

<p>尾递归指在函数最后执行递归调用的递归。</p>

<p>JS未做尾递归优化（变成循环），尝试递归可能因为堆栈溢出而运行失败。</p>

<h3>4.9作用域</h3>

<p>作用域控制变量和参数的可见性和生命周期，减少名称冲突，提供自动内存管理。</p>

<p>JS不支持块级作用域。</p>

<p>有函数作用域，在函数中任何位置定义的变量在函数中的任何位置可见。（注：可见指有这个字面量，不一定有值。如果先用，再定义，则用的值为undefined。 ）</p>

<h3>4.10闭包</h3>

<pre><code>var myObject = function(){
    var value=0;
    return {
        getValue:function(){
        return value;
    };
}

var anotherObject = myObject(); //这里的anotherObject实际上等于getValue函数所在的对象
anotherObject.getValue(); //0
</code></pre>

<p>getValue访问它被创建时所处的上下文环境，闭包。</p>

<p>重点是return回来是一个对象！可以不用new.</p>

<p>例子：</p>

<pre><code>var testfunc = function ( nodes ) {
    var i ;
    for ( i = 0 ; i &lt; nodes . length ; i ++ ) {

        //这种方案中的匿名函数因会被外部调用而被保留，而此时i为nodes.length
        /*nodes[i].onclick = function(){
            alert(i);
            alert(this.onclick);
            return false;
        }*/

        //这种方案中，将参数i所在函数当场执行，变成形参e，返回事件处理函数，该函数得到e，即循环当时的i值
        nodes [ i ] . onclick = function ( e ) {
            return function ( ) { //注：原书中这里和下一行的形参有误
                alert ( e ) ;
                alert ( this . onclick ) ;
                return false ;
            } ;
        } ( i ) ;
    }
}

testfunc ( document . getElementsByTagName ( “a” ) ) ;
</code></pre>

<h3>4.11回调</h3>

<p>异步，防止界面假死（客户端阻塞）</p>

<h3>4.12模块</h3>

<p>模块：提供接口却隐藏状态与实现的函数或对象。</p>

<pre><code>String.method(‘deentityify’,function(){
    var entity = {
        quot : ‘”‘,
        lt : ‘&lt;’,
        gt : ‘&gt;’
    }

    return function(){
        return this.replace(/&amp;([^&amp;;]+);/g,function(a,b){
            var r = entity[b];
            return typeof r === ‘string’ ? r : a;
        }
    }
}())
</code></pre>

<p>entity仅对内部可见</p>

<p>模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可访问到的地方。</p>

<h3>4.13级联</h3>

<p>如果让没有返回值的方法返回this而不是undefined，就可以启用级联。（如jQuery的连缀 ）</p>

<h3>4.14套用</h3>

<pre><code>var add1=add.curry(1);
add1(6)
</code></pre>

<h3>4.15记忆</h3>

<p>设计技巧。</p>
        ]]>
      </description>
    </item>
    <item>
      <title>《JavaScript语言精粹》读书笔记 第三章 对象</title>
      <link>http://www.toobug.net/article/javascript_the_good_parts_notes_chapter_3.html</link>
      <guid isPermaLink="true">http://www.toobug.net/article/javascript_the_good_parts_notes_chapter_3.html</guid>
      <pubDate>Wed, 27 Apr 2011 16:47:00 +0800</pubDate>
      <description>
        <![CDATA[
        <h3>3.0绪</h3>

<p>简单类型：数字、字符串、布尔、null、undefined</p>

<p>对象：数组、函数、正则表达式、对象</p>

<p>对象是属性的窗口，每个属性有名和值。</p>

<h3>3.1对象字面量</h3>

<p>对象字面量是包围在一对花括号中的零或多个名值对。</p>

<p>属性名允许空值。</p>

<p>如果属性名不是保留字，可以不用引号。</p>

<p>对象可嵌套。</p>

<h3>3.2检索</h3>

<p>方括号或者点语法，优先考虑用点语法，因为好看。</p>

<p>不存在的成员元素，返回undefined。</p>

<p>多级对象时，检索undefined会抛出TypeError。用&amp;&amp;解决：flight.equipent &amp;&amp; flight.equipment.model</p>

<h3>3.3更新</h3>

<p>赋值语句。</p>

<h3>3.4引用</h3>

<p>对象通过引用来传递，它们永远不会被拷贝！</p>

<h3>3.5原型</h3>

<p>每个对象都连接到一个原型对象，并可以从中继承属性。</p>

<p>所有通过字面量创建的对象都连接到Object.prototype。</p>
        ]]>
      </description>
    </item>
  </channel>
</rss>