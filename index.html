<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="description" content="TooBug - 专注前端开发">
    <meta name="keywords" content="TooBug,web前端,前端,HTML,CSS,JavaScript,js">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale:1.0,maximum-scale:2.0,user-scalable=yes">
    <title>TooBug</title>
    <link type="image/x-icon" rel="shortcut icon" href="/favicon.ico">
    <link rel="author" href="https://plus.google.com/106918118643022434563?rel=author">
    <link rel="alternate" type="application/rss+xml" title="TooBug" href="./rss/rss.xml">
    <link rel="stylesheet" href="./css/light.css">
    <link rel="stylesheet" href="./js/prettify/prettify.css">
    <script src="./js/prettify/prettify.js"></script>
    <script src="./js/jquery/jquery-1.7.2.min.js"></script>
    <script src="./js/index.js"></script>
  </head>
  <body>
    <header>
      <div id="logo"><a href="./index.html">TooBug</a><span class="subTitle">Life is too bug ...</span></div>
      <nav>
        <ul>
          <li><a href="./index.html">Index<br />首页</a></li>
          <li><a href="./page/about.html">About<br />关于</a></li>
        </ul>
      </nav>
    </header>
    <section id="sidebar">
      <div class="sideTitle">作者简介</div>
      <div id="intro" class="sideContent">
        <p class="avatar"><img src="http://tp4.sinaimg.cn/2160639311/180/5633952458/1"></p>
        <p><strong>TooBug</strong>，前端工程师，目前就职于<a href="http://www.futu5.com" target="_blank">富途网络</a>，曾任腾讯CDC前端工程师。</p>
        <p><a href="http://weibo.com/toooobug" target="_blank"><img src="http://www.sinaimg.cn/blog/developer/wiki/32x32.png"></a><a href="https://github.com/TooBug" target="_blank"><img src="http://cdn-img.easyicon.cn/png/10981/1098194.gif"></a></p>
      </div>
      <div class="sideTitle">友情链接</div>
      <div class="sideContent">
        <p>
          <ul class="friendLink">
            <li><a href="http://cdc.tencent.com" target="_blank">腾讯CDC</a></li>
            <li><a href="http://cdc.im" target="_blank">CDC前端博客</a></li>
            <li><a href="http://weba11y.cn" target="_blank">WebAccessibility</a></li>
            <li><a href="http://www.lesscss.net" target="_blank">LESS中国官网</a></li>
            <li><a href="http://www.gruntjs.org" target="_blank">Grunt中文社区</a></li>
            <li><a href="http://miyuki.42code.com" target="_blank">Miyuki的博客</a></li>
            <li><a href="http://www.basecss.net" target="_blank">Basecss的博客</a></li>
            <li><a href="http://skpping.cdc.im" target="_blank">Skpping的博客</a></li>
            <li><a href="http://solodu.com" target="_blank">Solo的博客</a></li>
            <li><a href="http://www.mxgw.info" target="_blank">梦想的港湾</a></li>
            <li><a href="http://www.uselessblog.cn" target="_blank">UseLess的博客</a></li>
            <li><a href="http://riny.net" target="_blank">Bubblings</a></li>
          </ul>
        </p>
      </div>
    </section>
    <section id="content">
      <div id="article">
        <div class="indexarticle">
          <h1><a href="./article/git_revert_merge.html">[译]Git回滚合并</a><em class="pubDate">2015-05-26</em></h1><p>如果工作流严重依赖分支合并的话，也难免会碰到需要回滚合并的情况。而且回滚还分为两种情况：永久回滚，或者回滚后在稍后重新合并。</p>

<p>假设有如下分支图：</p>

<p><img src="https://git-scm.com/images/unmerge1.png" alt="分支图" title="" /></p>

<blockquote>
  <p>注：Git分支图中的箭头表示依赖关系，并不是分支发展路线。发展路线和箭头是相反的。也就是图中是从C1开始一直发展到C12的。</p>
</blockquote>

<p>假设要回滚C10。</p>

<p>第一种解决方案是将<code>master</code>回退到C8，然后将两个特性分支<code>jk/post-checkout</code>和<code>db/push-cleanup</code>合并过来。</p>

<p><code>
git checkout master
git reset --hard [sha_of_C8]
git merge jk/post-checkout
git merge db/push-cleanup
</code></p>

<p>完成之后，分支图如下：</p>

<p><img src="https://git-scm.com/images/unmerge2.png" alt="分支图" title="" /></p>

<p>接下来就可以继续在新的<code>master</code>上工作，然后在适当的时候将<code>tv/rebase-stat</code>合并回来。</p>

<h2>回滚合并</h2>

<p>如果在很久之后才发现要回滚，或者其它人已经在合并之后提交了代码，分支图会是这样：</p>

<p><img src="https://git-scm.com/images/unmerge3.png" alt="分支图" title="" /></p>

<p>这种情况下要么回退一次合并，要么退回去，再重新合并，然后将新的变更（C9和C10）cherry-pick过来。后者容易让人迷惑，做起来也不容易，尤其是在合并之后提交很多的情况下。</p>

<p><code>git revert</code>能很好地处理合并的回退。你需要指定需要回退的那次合并提交记录，并指定保留合并中的哪一条线（parent）。假设我们需要回退合并<code>jk/post-checkout</code>的记录，则这样做：</p>

<p><code>
git revert -m 1 [sha_of_C8]
Finished one revert.
[master 88edd6d] Revert "Merge branch 'jk/post-checkout'"
 1 files changed, 0 insertions(+), 2 deletions(-)
</code></p>

<p>完成后会产生一个新提交，这个提交回滚了合并过来的内容。其结果和一个包含被合并过来分支改动的cherry-pick（反向操作，即回滚）差不多。</p>

<p><img src="https://git-scm.com/images/unmerge4.png" alt="分支图" title="" /></p>

<h2>回滚“回滚”</h2>

<p>假设在回滚之后，我们需要再次合并这个分支。如果你直接合并的话，什么都不会发生。</p>

<p><code>
git merge jk/post-checkout
Already up-to-date.
</code></p>

<p>更令人困惑的是，如果你回到分支，再做一些修改后再合并，则只有新产生的修改会被合并过来。</p>

<p><img src="https://git-scm.com/images/unmerge5.png" alt="分支图" title="" /></p>

<p>这种状态是一种非常奇怪的状态，有可能导致冲突或者难以理解的错误。此时你真正想做的事情应该是回滚“上一次对合并的回滚操作”。</p>

<p><code>
git revert 88edd6d
Finished one revert.
[master 268e243] Revert "Revert "Merge branch 'jk/post-checkout'""
 1 files changed, 2 insertions(+), 0 deletions(-)
</code></p>

<p><img src="https://git-scm.com/images/unmerge6.png" alt="分支图" title="" /></p>

<p>现在我们将分支恢复到了合并之后的情况，如果分支上有新的改动，就可以直接合并了。</p>

<p><code>
git merge jk/post-checkout
Auto-merging test.txt
Merge made by recursive.
 test.txt |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
</code></p>

<p><img src="https://git-scm.com/images/unmerge7.png" alt="分支图" title="" /></p>

<p>最后，建议使用<code>git merge --no-ff</code>合并分支，这样可以保持 分支不是快进的，使它可以回滚。</p>

<blockquote>
  <p>原文地址<a href="https://git-scm.com/blog/2010/03/02/undoing-merges.html">https://git-scm.com/blog/2010/03/02/undoing-merges.html</a>，本文并未逐字逐句翻译，仅根据理解摘录了重要部分。</p>
</blockquote>
          <div class="articlemore"><a href="./article/git_revert_merge.html">继续阅读</a></div>
        </div>
        <div class="indexarticle">
          <h1><a href="./article/git_and_gitflow.html">团队使用Git和Git-Flow手记</a><em class="pubDate">2015-05-11</em></h1><p>去年10月份，在我们被产品节奏逼到墙角无路可走的时候，我们在几乎没有准备的情况下，在团队中引入了Git。目前时间已经过去半年，回顾这半年的时间，基本还是运作得比较顺利。当然过程中也少不了踩坑，因此记录一些心得。</p>

<h2>Why Git?</h2>

<p>如果用一句话来说的话，我们是冲“分支”而来的。背景如下：</p>

<p>团队的固定版本节奏为两周一个版本，一周半的时间开发，半周时间测试发布。如果使用软件工程中的概念来说的话，这是一个比较典型的瀑布式流程，即“需求->设计->开发->测试->发布”，然后周而复始，过程中几乎没有重叠。</p>

<p>伴随着瀑布式的流程，代码也只有一份，“开发->改bug->发布”，周而复始。</p>

<p>直到去年10月，公司做了一场声势浩大的营销活动，灾难开始了：一方面需要以并不确定的研发周期支持各种运营活动（运营时间不等人，必须快速写快速发），一方面是运营活动带来大量客户，与客户相关的流程也陷入频繁修改发布的过程。此外支持各种终端需求也集中爆发，需要web侧快速跟进上线。当然，还有一个东西，就是上面瀑布流程中两周发布一次的“主版本”。当这么多版本交叠在一起时，我们发现必须要引入分支来管理研发过程。于是果断切Git。</p>
          <div class="articlemore"><a href="./article/git_and_gitflow.html">继续阅读</a></div>
        </div>
        <div class="indexarticle">
          <h1><a href="./article/using_pm2_deploy.html">使用PM2 Deploy部署基于Git版本管理的网站应用</a><em class="pubDate">2014-11-19</em></h1><p>按照官方介绍，PM2是一款用于生产环境Node.js应用进程管理的工具。按照民间介绍，它主要有这样几个功能：保证Node.js应用永远在线（挂掉自动重启）、自动负载均衡、零中断重启应用等。</p>

<p>鉴于它是如此优秀，这里还是简要介绍一下前两个功能。</p>

<h2>安装</h2>

<p>首先，它是一个Node.js写的工具，使用npm即可安装使用：</p>

<pre><code>npm install -g pm2
</code></pre>

<h2>运行Node.js程序</h2>

<p>如果不使用pm2，运行Node.js程序是这样：</p>

<pre><code>node xxx.js
</code></pre>

<p>使用pm2，是这样：</p>

<pre><code>pm2 start xxx.js
</code></pre>

<h3>监视模式</h3>

<p>如果你正在开发Node.js应用，需要在代码变更后自动重启应用，只需要在pm2的参数中加上<code>--watch</code>即可：</p>

<pre><code>pm2 start xxx.js --watch
</code></pre>
          <div class="articlemore"><a href="./article/using_pm2_deploy.html">继续阅读</a></div>
        </div>
        <div class="indexarticle">
          <h1><a href="./article/how_to_debug_efficiently.html">如何高效debug</a><em class="pubDate">2014-06-29</em></h1><blockquote>
  <p>这是一个公司内网上的问题，原意是题主觉得debug非常费时，影响了项目的效率，问如何改进。当时也在内网随手码了几点，回头又看了一遍觉得很有共性，可以再扩展一下单独写写，于是诞生此文。因为专业所限，本文的部分细节也只限于web前端，但思路和其它语言是相通的。</p>
</blockquote>

<p>首先，程序员要调整好心态。</p>

<p>事实上，debug是程序员工作的重要组成部分，甚至在产品的某些阶段是唯一的组成部分，所以不用把调bug看成是拖累产品进度、降低效率的凶手，这是一件必须要花时间认真去做的事情，它就是你的工作，也是整个项目进度过程中必不可少的组成部分。所以在debug的时候也可以更加平心静气一些，不用那么急躁。</p>

<p>当然，这个心态的改变也会涉及到项目进度安排上的一些调整，比如在排期的时候就要预估debug的时间，而不能仅仅只安排编码的时间。此外，还需要给自己做好时间管理，尽量能排比较大段的不被打扰的时间来debug。</p>

<p>把心态放平之后，有的bug可能解决起来真的就没那么耗时了。在心态平和、思路清晰、无人打扰的情况下，一般修起bug来都有如神助，效率高得连自己都不太敢相信。相反，往往越是着急的时候越是难定位到bug的真正原因。</p>
          <div class="articlemore"><a href="./article/how_to_debug_efficiently.html">继续阅读</a></div>
        </div>
        <div class="indexarticle">
          <h1><a href="./article/css_image_sprites_on_retina_screen.html">Retina屏下的CSS雪碧图</a><em class="pubDate">2014-03-19</em></h1><p>CSS雪碧图早已经成为前端知识体系中一个必备知识了，时至今日，可能很多人都觉得这一块已经没有什么东西可以再讲了的。但事实上雪碧图一直都可以引出新的话题，比如从最早的连接数和体积的平衡到格式之争到图像摆放位置的策略，再到合并图像的颗粒度，再到内存占用、CPU占用等性能问题……</p>

<p>没错，今天还要在这一古老的话题上展开，引入一个新的问题，那就是雪碧图在retina屏下存在的问题及应对方案。（值得注意的是，retina屏一般指分辨率为普通屏幕两倍的屏，这样按照普通尺寸开发出来的网站相当于被放大了2倍，会导致图像模糊之类的现象产生，理想的解决方案是为retina专门适配一套皮肤，但本文关注的问题是未适配retina屏幕的网站所出现的问题。）</p>

<blockquote>
  <p>雪碧图本身不是浏览器或者web标准中的技术，因此它的不少细节取决于浏览器的实现，本文中的讨论的内容正是如此，为避免争议，本文所有结论的得出场景限定为Mac OSX 10.9.1、Chrome浏览器V33。是否适用iPhone、iPad等场景未做相应测试。</p>
</blockquote>

<h2>无处不在的白边</h2>

<p>如前文所述，在retina屏上浏览未做专门适配的网站，会出现图像模糊等问题，无法达到最佳效果，但一般情况下，仍然处于可以接受的范围。不过，在某些网站上，却出现了比图像模糊更糟糕的情况：</p>

<p><img src="/images/css_image_sprites_on_retina_screen_1.png" alt="WebQQ在retina屏下出现白边" title="" /></p>
          <div class="articlemore"><a href="./article/css_image_sprites_on_retina_screen.html">继续阅读</a></div>
        </div>
        <div id="pagination"><a href="index.html">1</a><a href="index_page2.html">2</a><a href="index_page3.html">3</a><a href="index_page4.html">4</a><a href="index_page5.html">5</a><a href="index_page6.html">6</a><a href="index_page7.html">7</a><a href="index_page8.html">8</a>
        </div>
      </div>
    </section>
    <div id="foot">
      <p>Powered by <a href="https://github.com/TooooBug/solo" target="_blank">Solo</a></p>
      <script src="http://tajs.qq.com/stats?sId=22296323"></script>
    </div>
  </body>
</html>