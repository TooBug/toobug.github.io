<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="description" content="TooBug - 专注前端开发">
    <meta name="keywords" content="TooBug,web前端,前端,HTML,CSS,JavaScript,js">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale:1.0,maximum-scale:2.0,user-scalable=yes">
    <title>学习ES6生成器（Generator） - TooBug</title>
    <link type="image/x-icon" rel="shortcut icon" href="/favicon.ico">
    <link rel="author" href="https://plus.google.com/106918118643022434563?rel=author">
    <link rel="alternate" type="application/rss+xml" title="TooBug" href="../rss/rss.xml">
    <link rel="stylesheet" href="../css/light.css">
    <link rel="stylesheet" href="../js/prettify/prettify.css">
    <script src="../js/prettify/prettify.js"></script>
    <script src="../js/jquery/jquery-1.7.2.min.js"></script>
    <script src="../js/index.js"></script>
  </head>
  <body>
    <header>
      <div id="logo"><a href="../index.html">TooBug</a><span class="subTitle">Life is too bug ...</span></div>
      <nav>
        <ul>
          <li><a href="../index.html">Index<br />首页</a></li>
          <li><a href="../page/about.html">About<br />关于</a></li>
        </ul>
      </nav>
    </header>
    <section id="sidebar">
      <div class="sideTitle">作者简介</div>
      <div id="intro" class="sideContent">
        <p class="avatar"><img src="http://tp4.sinaimg.cn/2160639311/180/5633952458/1"></p>
        <p><strong>TooBug</strong>，前端工程师，目前就职于<a href="http://cdc.tencent.com" target="_blank">腾讯CDC</a>。关注体验设计，关注大前端生态圈。</p>
        <p><a href="http://weibo.com/toooobug" target="_blank"><img src="http://www.sinaimg.cn/blog/developer/wiki/32x32.png"></a><a href="http://t.qq.com/TooBug" target="_blank"><img src="http://mat1.gtimg.com/app/opent/images/wiki/resource/weiboicon32.png"></a><a href="https://github.com/TooBug" target="_blank"><img src="http://cdn-img.easyicon.cn/png/10981/1098194.gif"></a></p>
      </div>
      <div class="sideTitle">友情链接</div>
      <div class="sideContent">
        <p>
          <ul class="friendLink">
            <li><a href="http://cdc.tencent.com" target="_blank">腾讯CDC</a></li>
            <li><a href="http://cdc.im" target="_blank">CDC前端博客</a></li>
            <li><a href="http://www.lesscss.net" target="_blank">LESS中国官网</a></li>
            <li><a href="http://www.gruntjs.org" target="_blank">Grunt中文社区</a></li>
            <li><a href="http://miyuki.42code.com" target="_blank">Miyuki的博客</a></li>
            <li><a href="http://www.basecss.net" target="_blank">Basecss的博客</a></li>
            <li><a href="http://skpping.cdc.im" target="_blank">Skpping的博客</a></li>
            <li><a href="http://www.mxgw.info" target="_blank">梦想的港湾</a></li>
            <li><a href="http://www.veryued.org" target="_blank">飞长的博客</a></li>
            <li><a href="http://frontlan.com" target="_blank">兰悦儿格格</a></li>
          </ul>
        </p>
      </div>
    </section>
    <section id="content">
      <div id="article">
        <h1>学习ES6生成器（Generator）<em class="pubDate">2013-12-29 13:35:00</em></h1><p>这几天，TJ大神的koa框架突然在国内火起来了，随之而来的，则是其使用的ES6生成器（Generator）引起了广大码农的强烈兴趣，各种文章也如寸后春笋般拔地而起，比如<a href="https://www.imququ.com/post/generator-function-in-es6.html">这篇</a>、<a href="http://bg.biedalian.com/2013/12/21/harmony-generator.html">这篇</a>、还有<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Guide/Iterators_and_Generators">这篇</a>。这个神奇的生成器被视为解决JS“回调恶魔金字塔”的利器。在动手实践之后，发现介绍ES6生成器的文章仍然有些疏漏，因此有了这篇文章，权当是对各位大大们的补充好了。</p>

<h2>背景</h2>

<p>在JS的使用场景中，异步操作的处理是一个不可回避的问题，如果不做任何抽象、组织，只是“跟着感觉走”，那么面对“按顺序发起3个ajax请求”的需求，很容易就能写出如下代码（假设已引入jQuery）：</p>

<pre><code>// 第1个ajax请求
$.ajax({
    url:'http://echo.113.im',
    dateType:'json',
    type:'get',
    data:{
        data:JSON.stringify({status:1,data:'hello world'}),
        type:'json',
        timeout:1000
    },
    success:function(data){
        if(data.status === 1){
            // 第2个ajax请求
            $.ajax({
                ......此处省略500字
                success:function(data){
                    if(data.status === 1){
                        // 第3个ajax请求
                        $.ajax({
                            ......此处省略500字
                            success:function(data){
                                if(data.status === 1){

                                }
                            }
                        });
                    }
                }
            });
        }
    }
});
</code></pre>

<p>当顺序执行的异步操作越来越多的时候，回调层级也就越多，这也就是传说中的“回调恶魔金字塔”，在本文章中，我们给它另一个名字“被动异步”。</p>

<p>还有一种场景，比如老赵的Wind.js总喜欢用的经典例子，对一个数组进行排序，但要动态展示排序过程（<a href="http://windjs.org/cn/docs/async/samples/browser/sorting-animations/">详情</a>）。</p>

<p>在这种情况下，为了使动画能够正确呈现，我们不得不对“排序”这一本来不涉及到异步操作的逻辑做些改动，强制添加延时操作，使它变成一个异步操作。（如不理解，请搜索“JavaScript动画原理”。）</p>

<p>在本文中，我们给这种场景也起一个名字，叫“主动异步”。</p>

<h2>生成器的卢山真面目</h2>

<p>所谓“生成器”，其实是一个函数，但是这个函数的行为会比较特殊：</p>

<ol>
<li>它并不直接执行逻辑，而是用来生成另一个对象（这也正是“生成器”的含义）</li>
<li>它所生成的对象中的函数可以把逻辑拆开来，一片一片调用执行，而不是像普通的函数，只能从头到尾一次执行完毕</li>
</ol>

<p>生成器的语法和普通函数类似，特殊之处在于：</p>

<ol>
<li>字面量（函数声明/函数表达式）的关键字<code>function</code>后面多了一个<code>*</code>，而且这个<code>*</code>前后允许有空白字符</li>
<li>函数体中多了<code>yield</code>运算符</li>
</ol>

<p>举个粟子：</p>

<pre><code>function * GenA(){
    console.log('from GenA, first.');
    yield 1;
    console.log('from GenA, second.');
    var value3 = yield 2;
    console.log('from GenA, third.',value3);
    return 3;
}

var a = new GenA();
</code></pre>

<p>接下来依次执行：</p>

<pre><code>a.next();
// from GenA, first.
// Object {value:1,done:false}

a.next();
// from GenA, second.
// Object {value:2,done:false}

a.next(333);
// from GenA, third.
// 333
// Object {value:3,done:true}

a.next();
// Error: Generator has already finished
</code></pre>

<p>这个例子反映了生成器的基本用法，有以下几点值得注意：</p>

<ol>
<li>在调用<code>GenA()</code>时，函数体中的逻辑并不会执行（控制台没有输出），直接调用a.next()时才会执行</li>
<li><code>a</code>是一个对象，它由生成器<code>GenA()</code>实例化而来（事实上，不需要<code>new</code>运算符也是一样的结果）</li>
<li>调用<code>a.next()</code>时，函数体中的逻辑才开始真正执行，每次调用时会到<code>yield</code>语句结束，并将<code>yield</code>的运算数作为结果返回</li>
<li><code>a.next()</code>返回的结果是一个对象，对<code>yield</code>的运算数做了包装，并带上了<code>done</code>属性</li>
<li>当<code>done</code>属性为<code>false</code>时，表示该函数逻辑还未执行完，可以调用<code>a.next()</code>继续执行，否则不可继续调用</li>
<li>最后一次返回的结果为<code>return</code>语句返回的结果，且<code>done</code>值为<code>true</code>。如果不写<code>return</code>，则值为<code>undefined</code></li>
<li><code>value3 = yield 2</code>这句是指，这一段逻辑返回2，在下一次调用<code>a.next()</code>时，将参数赋给value3。换句话说，这句只执行了后面半段就暂停了，等到再次调用<code>a.next()</code>时才会将参数赋给value3并继续执行下面的逻辑</li>
</ol>

<h2>同步场景下生成器的使用</h2>

<p>来看看同步场景下，如何使用生成器：</p>

<pre><code>function * Square(){
    for(var i=1;;i++){
        yield i*i;
    }
}

var square = new Square();

square.next(); // 1
square.next(); // 4
square.next(); // 9
......
</code></pre>

<p>同步场景下大概就是这么用的，很无趣是吧？我也这么觉得，其实和直接函数调用差别不大。不过值得注意的是，我们在循环中并没有设中止条件，因为调用一个<code>square.next()</code>方法，它才会执行一次，不调用则不执行，所以不用担心死循环的问题。</p>

<h2>主动异步场景下生成器的使用</h2>

<p>如前文所说，“主动异步”这个概念是在本文中提出来的，指那些因为某些原因需要手工延时，将同步操作变成异步操作的场景。举个简单的例子，以秒为单位，依次在console中输出1、2、3……的平方值：</p>

<pre><code>function doSquare(number){
    console.log(number * number);
    setTimeout(function(){
        doSquare(number+1);
    },1000);
}

doSquare(1);
</code></pre>

<p>如果换用生成器来做，可以这么写：</p>

<pre><code>function * Square(){
    for(var i=1;;i++){
        yield i*i;
    }
}

var square = new Square();
console.log(square.next().value);
setInterval(function(){
    console.log(square.next().value);
},1000);
</code></pre>

<p>是不是觉得和同步的场景很像呀？其实就生成器<code>Square()</code>来讲，几乎是一样的，只是在调用的时候加了一个延时。这是因为生成器的特性中，并不包含异步的支持（唯一有点关联的就是上面提到的<code>var varible = yield value</code>了），所以异步的操作仍然要在其它地方处理。就这个具体的例子而言，生成器并未为我们带来任何惊喜。</p>

<h2>被动异步场景下的生成器使用</h2>

<p>如前文所说，“被动异步”是本文中约定的概念，指那些操作本身就是异步的，没有办法将延时和操作本身分享开来的操作，比如ajax请求，没办法将请求和延时分离开处理。（上例“主动异步”中的延时则是手工加的，既可以放在<code>Square</code>中，也可以放在<code>Square</code>外。）</p>

<p>那么，如何用生成器解决这种被动异步场景下的“回调恶魔金字塔”呢？满心期待对吧，很遗憾，它并不能那么简单地解决……</p>

<p>从前面的例子中，其实已经可以体会出来了，生成器的用法中并不包含对异步的处理，所以其实没有办法帮助我们对异步回调进行封闭。那么为什么大家将它视为解决回调嵌套的神器呢？在翻阅了不少资料后找到<a href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/">这篇文章</a>，文章作者一开始也认为生成器并不能解决回调嵌套的问题，但下面自己做了解释，如果生成器的返回的是一系列的Promise对象的话，情况就会不一样了，举个粟子：</p>

<pre><code>function myAjax1(){
    return $.getJSON('http://echo.113.im',{
        data:JSON.stringify({data:1}),
        type:'json'
    });
}
</code></pre>

<p>我们使用jQuery中的getJSON方法还处理ajax请求，这个方法会返回一个Promise对象。然后，我们使用一个生成器来包装这个操作：</p>

<pre><code>function * MyLogic(){
    var serverData = yield myAjax1();
    console.log(serverData)
}
</code></pre>

<p>使用的时候这样用：</p>

<pre><code>var myLogic = new MyLogic();
var promise = myLogic.next().value;
promise.done(function(serverData){
    myLogic.next(serverData);
});
</code></pre>

<p>可以看到，我们这里的<code>myAjax1()</code>以及<code>MyLogic()</code>函数中，并没有使用回调，就完成了异步操作。你一定会问，下面这个<code>promise.done</code>不就是回调操作么？Bingo！这正是精华所在！我们来看一下这段代码做了什么：</p>

<p>首先，<code>myLogic.next()</code>返回了一个Promise对象（<code>promise</code>），然后，<code>promise.done</code>中的回调函数所做的事情就是调用<code>next</code>方法就行了，除了调用<code>next</code>方法，其它的什么事情都没有。此时，我们就会想到一个程序员特别喜欢的词，叫“封装”！既然这个回调函数只是调用<code>next</code>方法，那为什么不把它封装起来？</p>

<p>了解到这里，再去看<a href="http://bg.biedalian.com/2013/12/21/harmony-generator.html">这篇</a>文章中所说的<code>co</code>函数，相信你就恍然大悟了！这个<code>co</code>函数正是在封装调用<code>next</code>方法这件事情！</p>

<pre><code>function co(GenFunc) {
    return function(cb) {
        var gen = GenFunc()
        next()
        function next() {
            if (gen.next) {
                var ret = gen.next()
                if (ret.done) { // 如果结束就执行cb
                    cb &amp;&amp; cb()
                } else { // 继续next
                    ret.value(next)
                }
            }
        }
    }
}
</code></pre>

<p>当我们把这个细节屏蔽之后，再回头去看我们的异步代码，是不是就没有回调了？！哇噻，怎么办到的？好神奇啊！</p>

<p>最后，以别人文章中的一段koa框架使用代码收尾吧：</p>

<pre><code>var koa = require('koa'),
    app = koa();

app.use(function *() {

    // 这是这个例子中最重要的部分，我们进行了一系列异步操作，却没有回调
    var city = yield geolocation.getCityAsync(this.req.ip);
    var forecast = yield weather.getForecastAsync(city);

    this.body = 'Today, ' + city + ' will be ' + forecast.temperature + ' degrees.';

});

app.listen(8080);
</code></pre>

<p>看到了吧，koa正是封装了对生成器返回值的处理和调用<code>next</code>方法的细节（这里的<code>app.use</code>就像前面的<code>co</code>函数），使得我们的逻辑代码看起来是如此简单，这正是koa的伟大之处，也是ES6生成器这一特性能迅速引起如此多轰动的真正原因。</p>

<blockquote>
  <p>P.S: 本文中的“主动异步”和“被动异步”其实都可以用同样的方式来封装，中间加入“主动同步”的内容只是为了正好地理解异步场景。另外对Promise不了解的同学建议先了解Promise的基本用法再理解生成器比较好。</p>
</blockquote>
      </div>
      <div id="disqus_thread"></div>
      <script>
        var disqus_shortname = 'toobug';
        (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
      <noscript>
        <Please>enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></Please>
      </noscript>
    </section>
    <div id="foot">
      <p>Powered by <a href="https://github.com/TooooBug/solo" target="_blank">Solo</a></p>
      <script src="http://tajs.qq.com/stats?sId=22296323"></script>
    </div>
  </body>
</html>